import os
import json
from datetime import datetime, timedelta
from collections import defaultdict
from zoneinfo import ZoneInfo
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, ContextTypes
from supabase import create_client, Client

# Estados da conversa
AGUARDANDO_SA, AGUARDANDO_GPON, AGUARDANDO_FOTOS, AGUARDANDO_DATA_INICIO, AGUARDANDO_DATA_FIM, AGUARDANDO_NOME, AGUARDANDO_SOBRENOME, AGUARDANDO_REGIAO, AGUARDANDO_CONSULTA = range(9)

# Arquivo para salvar os dados
DADOS_FILE = 'instalacoes.json'
USUARIOS_FILE = 'usuarios.json'
TZ = ZoneInfo("America/Sao_Paulo")

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
USE_SUPABASE = bool(SUPABASE_URL and SUPABASE_KEY)
_SUPABASE_CLIENT = None

def get_supabase():
    global _SUPABASE_CLIENT
    if not USE_SUPABASE:
        return None
    if _SUPABASE_CLIENT is None:
        _SUPABASE_CLIENT = create_client(SUPABASE_URL, SUPABASE_KEY)
    return _SUPABASE_CLIENT

# Carregar dados existentes
def carregar_dados():
    try:
        sb = get_supabase()
        resp = sb.table("instalacoes").select("*").execute()
        data = resp.data or []
        return data
    except:
        return []

# Salvar dados
def salvar_dados(dados):
    try:
        sb = get_supabase()
        if isinstance(dados, list):
            if dados:
                sb.table("instalacoes").insert(dados).execute()
        else:
            sb.table("instalacoes").insert(dados).execute()
    except:
        pass

def carregar_usuarios():
    try:
        sb = get_supabase()
        resp = sb.table("usuarios").select("*").execute()
        rows = resp.data or []
        usuarios = {}
        for r in rows:
            uid = str(r.get('id'))
            usuarios[uid] = {
                'nome': r.get('nome') or '',
                'sobrenome': r.get('sobrenome') or '',
                'regiao': r.get('regiao'),
                'telegram': r.get('telegram')
            }
        return usuarios
    except:
        return {}

def salvar_usuarios(usuarios):
    try:
        sb = get_supabase()
        payload = []
        for k, v in (usuarios or {}).items():
            payload.append({
                'id': int(k) if str(k).isdigit() else str(k),
                'nome': v.get('nome') or '',
                'sobrenome': v.get('sobrenome') or '',
                'regiao': v.get('regiao'),
                'telegram': v.get('telegram')
            })
        if payload:
            sb.table("usuarios").upsert(payload).execute()
    except:
        pass

def salvar_usuario(uid: str, dados_usuario: dict):
    try:
        sb = get_supabase()
        row = {
            'id': int(uid) if str(uid).isdigit() else str(uid),
            'nome': dados_usuario.get('nome') or '',
            'sobrenome': dados_usuario.get('sobrenome') or '',
            'regiao': dados_usuario.get('regiao'),
            'telegram': dados_usuario.get('telegram')
        }
        sb.table("usuarios").upsert(row).execute()
    except:
        pass

def salvar_instalacao(instalacao: dict):
    try:
        sb = get_supabase()
        sb.table("instalacoes").insert(instalacao).execute()
    except:
        pass

# Comando /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
    if str(user_id) not in usuarios:
        context.user_data['ident'] = {}
        await update.message.reply_text('üë§ Primeiro acesso. Informe seu nome:')
        return AGUARDANDO_NOME
    keyboard = [
        [InlineKeyboardButton("üìù Registrar Instala√ß√£o", callback_data='registrar')],
        [InlineKeyboardButton("üîç Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("üìä Minhas Instala√ß√µes", callback_data='minhas')],
        [InlineKeyboardButton("üìÜ Consulta Produ√ß√£o", callback_data='consulta_producao')],
        [InlineKeyboardButton("üìà Relat√≥rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'üõ†Ô∏è *Bot de Registro de Instala√ß√µes*\n\n'
        'Bem-vindo! Escolha uma op√ß√£o:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    return ConversationHandler.END

async def receber_nome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['nome'] = update.message.text.strip()
    await update.message.reply_text('Informe seu sobrenome:')
    return AGUARDANDO_SOBRENOME

async def receber_sobrenome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['sobrenome'] = update.message.text.strip()
    await update.message.reply_text('Informe sua regi√£o de atua√ß√£o:')
    return AGUARDANDO_REGIAO

async def receber_regiao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    regiao = update.message.text.strip()
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
    ident = context.user_data.get('ident', {})
    dados_usuario = {
        'nome': ident.get('nome', ''),
        'sobrenome': ident.get('sobrenome', ''),
        'regiao': regiao,
        'telegram': update.message.from_user.username or update.message.from_user.first_name
    }
    usuarios[str(user_id)] = dados_usuario
    salvar_usuario(str(user_id), dados_usuario)
    keyboard = [
        [InlineKeyboardButton("üìù Registrar Instala√ß√£o", callback_data='registrar')],
        [InlineKeyboardButton("üîç Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("üìä Minhas Instala√ß√µes", callback_data='minhas')],
        [InlineKeyboardButton("üìà Relat√≥rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        '‚úÖ Perfil salvo!\n\nAgora voc√™ pode usar o menu:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    context.user_data.pop('ident', None)
    return ConversationHandler.END

# Menu de relat√≥rios
async def menu_relatorios(query):
    keyboard = [
        [InlineKeyboardButton("üìÖ Relat√≥rio Mensal", callback_data='rel_mensal')],
        [InlineKeyboardButton("üìä Relat√≥rio Semanal", callback_data='rel_semanal')],
        [InlineKeyboardButton("üìÜ Relat√≥rio por Per√≠odo", callback_data='rel_periodo')],
        [InlineKeyboardButton("üìà Relat√≥rio Hoje", callback_data='rel_hoje')],
        [InlineKeyboardButton("üèÜ Ranking T√©cnicos", callback_data='rel_ranking')],
        [InlineKeyboardButton("üîô Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        'üìà *Relat√≥rios Dispon√≠veis*\n\n'
        'Escolha o tipo de relat√≥rio:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Gerar relat√≥rio mensal
def gerar_relatorio_mensal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    mes_atual = agora.month
    ano_atual = agora.year
    
    # Filtrar instala√ß√µes do m√™s atual
    instalacoes_mes = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.month == mes_atual and data_inst.year == ano_atual:
                instalacoes_mes.append(inst)
        except:
            continue
    
    if not instalacoes_mes:
        return "‚ùå Nenhuma instala√ß√£o registrada neste m√™s."
    
    # Contar por t√©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_mes:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    nome_mes = agora.strftime('%B/%Y')
    msg = f'üìÖ *Relat√≥rio Mensal - {nome_mes}*\n\n'
    msg += f'üìä *Total de Instala√ß√µes:* {len(instalacoes_mes)}\n\n'
    msg += 'üë• *Por T√©cnico:*\n'
    
    # Ordenar por quantidade (maior para menor)
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  ‚Ä¢ {tecnico}: *{quantidade}* instala√ß√µes\n'
    
    # M√©dia di√°ria
    dias_mes = agora.day
    media_dia = len(instalacoes_mes) / dias_mes
    msg += f'\nüìà *M√©dia di√°ria:* {media_dia:.1f} instala√ß√µes/dia'
    
    return msg

# Gerar relat√≥rio semanal
def gerar_relatorio_semanal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    inicio_semana = agora - timedelta(days=agora.weekday())
    inicio_semana = inicio_semana.replace(hour=0, minute=0, second=0, microsecond=0)
    
    # Filtrar instala√ß√µes da semana
    instalacoes_semana = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst >= inicio_semana:
                instalacoes_semana.append(inst)
        except:
            continue
    
    if not instalacoes_semana:
        return "‚ùå Nenhuma instala√ß√£o registrada nesta semana."
    
    # Contar por t√©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_semana:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    msg = f'üìä *Relat√≥rio Semanal*\n'
    msg += f'Per√≠odo: {inicio_semana.strftime("%d/%m")} at√© {agora.strftime("%d/%m/%Y")}\n\n'
    msg += f'üìä *Total de Instala√ß√µes:* {len(instalacoes_semana)}\n\n'
    msg += 'üë• *Por T√©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  ‚Ä¢ {tecnico}: *{quantidade}* instala√ß√µes\n'
    
    # M√©dia di√°ria da semana
    dias_semana = (agora - inicio_semana).days + 1
    media_dia = len(instalacoes_semana) / dias_semana
    msg += f'\nüìà *M√©dia di√°ria:* {media_dia:.1f} instala√ß√µes/dia'
    
    return msg

# Gerar relat√≥rio do dia
def gerar_relatorio_hoje():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    
    # Filtrar instala√ß√µes de hoje
    instalacoes_hoje = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.date() == agora.date():
                instalacoes_hoje.append(inst)
        except:
            continue
    
    if not instalacoes_hoje:
        return "‚ùå Nenhuma instala√ß√£o registrada hoje."
    
    # Contar por t√©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_hoje:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    msg = f'üìà *Relat√≥rio de Hoje - {agora.strftime("%d/%m/%Y")}*\n\n'
    msg += f'üìä *Total de Instala√ß√µes:* {len(instalacoes_hoje)}\n\n'
    msg += 'üë• *Por T√©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  ‚Ä¢ {tecnico}: *{quantidade}* instala√ß√µes\n'
    
    return msg

# Gerar ranking geral
def gerar_ranking_tecnicos():
    dados = carregar_dados()
    
    if not dados:
        return "‚ùå Nenhuma instala√ß√£o registrada ainda."
    
    # Contar por t√©cnico (todos os tempos)
    por_tecnico = defaultdict(int)
    for inst in dados:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    msg = f'üèÜ *Ranking Geral de T√©cnicos*\n\n'
    msg += f'üìä *Total Geral:* {len(dados)} instala√ß√µes\n\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    
    medals = ['ü•á', 'ü•à', 'ü•â']
    for idx, (tecnico, quantidade) in enumerate(tecnicos_ordenados, 1):
        medal = medals[idx-1] if idx <= 3 else f'{idx}¬∫'
        percentual = (quantidade / len(dados)) * 100
        msg += f'{medal} *{tecnico}*\n'
        msg += f'   {quantidade} instala√ß√µes ({percentual:.1f}%)\n\n'
    
    return msg

# Callback dos bot√µes
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'registrar':
        await query.edit_message_text(
            'üìù *Nova Instala√ß√£o*\n\n'
            'Por favor, envie o *n√∫mero da SA*:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'consultar':
        await query.edit_message_text(
            'üîç *Consultar Instala√ß√£o*\n\n'
            'Digite o n√∫mero da SA ou do GPON para buscar:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_CONSULTA

    elif query.data == 'consulta_producao':
        context.user_data['modo'] = 'producao'
        await query.edit_message_text(
            'üìÜ *Consulta Produ√ß√£o*\n\nEnvie a *data inicial* no formato `dd/mm/aaaa`:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_DATA_INICIO
    
    elif query.data == 'minhas':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        
        instalacoes_user = [d for d in dados if d.get('tecnico_id') == user_id]
        
        if not instalacoes_user:
            await query.edit_message_text('Voc√™ ainda n√£o registrou nenhuma instala√ß√£o.')
            return None
        
        msg = f'üìä *Suas Instala√ß√µes ({len(instalacoes_user)})*\n\n'
        for i, inst in enumerate(instalacoes_user[-10:], 1):  # √öltimas 10
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
        
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'relatorios':
        await menu_relatorios(query)
        return None
    
    elif query.data == 'rel_mensal':
        msg = gerar_relatorio_mensal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_semanal':
        msg = gerar_relatorio_semanal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_hoje':
        msg = gerar_relatorio_hoje()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_periodo':
        await query.edit_message_text(
            'üìÜ *Relat√≥rio por Per√≠odo*\n\nEnvie a *data inicial* no formato `dd/mm/aaaa`:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_DATA_INICIO
    
    elif query.data == 'rel_ranking':
        msg = gerar_ranking_tecnicos()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'voltar':
        keyboard = [
            [InlineKeyboardButton("üìù Registrar Instala√ß√£o", callback_data='registrar')],
            [InlineKeyboardButton("üîç Consultar SA/GPON", callback_data='consultar')],
            [InlineKeyboardButton("üìä Minhas Instala√ß√µes", callback_data='minhas')],
            [InlineKeyboardButton("üìÜ Consulta Produ√ß√£o", callback_data='consulta_producao')],
            [InlineKeyboardButton("üìà Relat√≥rios", callback_data='relatorios')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            'üõ†Ô∏è *Bot de Registro de Instala√ß√µes*\n\n'
            'Bem-vindo! Escolha uma op√ß√£o:',
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        return None

# Receber n√∫mero da SA
async def receber_sa(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['sa'] = update.message.text.strip()
    await update.message.reply_text(
        '‚úÖ SA registrada!\n\n'
        'Agora envie o *GPON*:',
        parse_mode='Markdown'
    )
    return AGUARDANDO_GPON

# Receber GPON
async def receber_gpon(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['gpon'] = update.message.text.strip()
    context.user_data['fotos'] = []
    
    await update.message.reply_text(
        '‚úÖ GPON registrado!\n\n'
        'üì∏ Agora envie as *3 fotos* da instala√ß√£o.\n'
        'Quando terminar, digite /finalizar',
        parse_mode='Markdown'
    )
    return AGUARDANDO_FOTOS

# Receber fotos
async def receber_foto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'fotos' not in context.user_data:
        context.user_data['fotos'] = []
    
    # Pega a foto de maior resolu√ß√£o
    photo = update.message.photo[-1]
    file_id = photo.file_id
    context.user_data['fotos'].append(file_id)
    
    num_fotos = len(context.user_data['fotos'])
    
    if num_fotos < 3:
        await update.message.reply_text(
            f'‚úÖ Foto {num_fotos}/3 recebida!\n'
            f'Envie mais {3 - num_fotos} foto(s) ou /finalizar se j√° enviou todas.'
        )
    else:
        await update.message.reply_text(
            f'‚úÖ {num_fotos} fotos recebidas!\n'
            'Digite /finalizar para salvar a instala√ß√£o.'
        )
    
    return AGUARDANDO_FOTOS

# Finalizar registro
async def finalizar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'sa' not in context.user_data or 'gpon' not in context.user_data:
        await update.message.reply_text('‚ùå Erro: Dados incompletos. Use /start para come√ßar novamente.')
        return ConversationHandler.END
    
    usuarios = carregar_usuarios()
    uid = str(update.message.from_user.id)
    perfil = usuarios.get(uid)
    tecnico_nome = (f"{perfil.get('nome','')} {perfil.get('sobrenome','')}".strip() if perfil else (update.message.from_user.username or update.message.from_user.first_name))
    tecnico_regiao = (perfil.get('regiao') if perfil else None)
    
    nova_instalacao = {
        'sa': context.user_data['sa'],
        'gpon': context.user_data['gpon'],
        'fotos': context.user_data.get('fotos', []),
        'tecnico_id': update.message.from_user.id,
        'tecnico_nome': tecnico_nome,
        'tecnico_regiao': tecnico_regiao,
        'data': datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    }
    
    salvar_instalacao(nova_instalacao)
    
    await update.message.reply_text(
        '‚úÖ *Instala√ß√£o registrada com sucesso!*\n\n'
        f'üìã SA: `{nova_instalacao["sa"]}`\n'
        f'üîå GPON: `{nova_instalacao["gpon"]}`\n'
        f'üì∏ Fotos: {len(nova_instalacao["fotos"])}\n'
        f'üë§ T√©cnico: {nova_instalacao["tecnico_nome"]}\n'
        f'üìç Regi√£o: {nova_instalacao["tecnico_regiao"] or "n√£o informada"}\n'
        f'üìÖ Data: {nova_instalacao["data"]}\n\n'
        'Use /start para nova a√ß√£o.',
        parse_mode='Markdown'
    )
    
    context.user_data.clear()
    return ConversationHandler.END

# Consultar instala√ß√£o por SA ou GPON
async def consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto_busca = update.message.text.strip()
    dados = carregar_dados()

    termo = texto_busca.lower()
    resultados = []
    for d in dados:
        sa = str(d.get('sa') or '').lower()
        gpon = str(d.get('gpon') or '').lower()
        if termo in sa or termo in gpon:
            resultados.append(d)

    if not resultados:
        await update.message.reply_text(
            f'‚ùå Nenhuma instala√ß√£o encontrada para: `{texto_busca}`',
            parse_mode='Markdown'
        )
        return ConversationHandler.END

    for resultado in resultados:
        msg = (
            f'üìã *SA:* `{resultado["sa"]}`\n'
            f'üîå *GPON:* `{resultado["gpon"]}`\n'
            f'üë§ *T√©cnico:* {resultado["tecnico_nome"]}`\n'
            f'üìÖ *Data:* {resultado["data"]}`\n'
            f'üì∏ *Fotos:* {len(resultado.get("fotos", []))}'
        )
        
        await update.message.reply_text(msg, parse_mode='Markdown')
        
        # Enviar as fotos
        for foto_id in resultado.get('fotos', []):
            try:
                await update.message.reply_photo(photo=foto_id)
            except:
                pass
    return ConversationHandler.END

async def comando_consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        'üîç *Consultar Instala√ß√£o*\n\n'
        'Digite o n√∫mero da SA ou do GPON para buscar:',
        parse_mode='Markdown'
    )
    return AGUARDANDO_CONSULTA

# Comando /mensal (atalho direto)
async def comando_mensal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_mensal()
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /semanal (atalho direto)
async def comando_semanal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_semanal()
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /hoje (atalho direto)
async def comando_hoje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_hoje()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def receber_data_inicio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        inicio = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('‚ùå Data inv√°lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_INICIO
    context.user_data['data_inicio'] = inicio
    modo = context.user_data.get('modo')
    if modo == 'producao':
        await update.message.reply_text('Agora envie a *data de fechamento* no formato `dd/mm/aaaa`:', parse_mode='Markdown')
    else:
        await update.message.reply_text('Agora envie a *data final* no formato `dd/mm/aaaa`:', parse_mode='Markdown')
    return AGUARDANDO_DATA_FIM

async def iniciar_producao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['modo'] = 'producao'
    await update.message.reply_text('üìÜ *Consulta Produ√ß√£o*\n\nEnvie a *data inicial* no formato `dd/mm/aaaa`:', parse_mode='Markdown')
    return AGUARDANDO_DATA_INICIO

async def receber_data_fim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        fim = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('‚ùå Data inv√°lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio = context.user_data.get('data_inicio')
    if not inicio:
        await update.message.reply_text('‚ùå Erro: envie a data inicial primeiro.', parse_mode='Markdown')
        return ConversationHandler.END
    if fim < inicio:
        await update.message.reply_text('‚ùå A data final √© anterior √† inicial. Envie novamente a data final.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio_dt = inicio.replace(hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=TZ)
    fim_dt = fim.replace(hour=23, minute=59, second=59, microsecond=0).replace(tzinfo=TZ)
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'‚ùå Nenhuma instala√ß√£o encontrada entre {inicio.strftime("%d/%m/%Y")} e {fim.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        context.user_data.pop('data_inicio', None)
        context.user_data.pop('modo', None)
        return ConversationHandler.END
    modo = context.user_data.get('modo')
    if modo == 'producao':
        dias_periodo = (fim_dt - inicio_dt).days + 1
        media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
        msg = (
            f'üìÜ *Produ√ß√£o no Per√≠odo*\n'
            f'Per√≠odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'üë§ T√©cnico: {username}\n\n'
            f'üìä *Total de Instala√ß√µes:* {len(instalacoes_user)}\n'
            f'üìà *M√©dia di√°ria:* {media_dia:.1f} instala√ß√µes/dia\n'
        )
        await update.message.reply_text(msg, parse_mode='Markdown')
    else:
        msg = (
            f'üìÜ *Relat√≥rio por Per√≠odo*\n'
            f'Per√≠odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'üë§ T√©cnico: {username}\n\n'
            f'üìä *Total de Instala√ß√µes:* {len(instalacoes_user)}\n\n'
        )
        ultimos = instalacoes_user[-10:]
        i = 1
        for inst in ultimos:
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
            i += 1
        await update.message.reply_text(msg, parse_mode='Markdown')
    context.user_data.pop('data_inicio', None)
    context.user_data.pop('modo', None)
    return ConversationHandler.END

# Cancelar opera√ß√£o
async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('‚ùå Opera√ß√£o cancelada. Use /start para come√ßar novamente.')
    context.user_data.clear()
    return ConversationHandler.END

# Configurar o bot
def main():
    def _clean_token(s: str):
        s = s.strip()
        for ch in ('`', '"', "'", '\r', '\n'):
            s = s.replace(ch, '')
        return s

    def _get_token():
        t = os.getenv("TELEGRAM_TOKEN")
        if t:
            return _clean_token(t)
        for p in ("/etc/secrets/TELEGRAM_TOKEN", "TELEGRAM_TOKEN"):
            try:
                if os.path.exists(p):
                    with open(p, "r", encoding="utf-8") as f:
                        c = _clean_token(f.read())
                        if c:
                            return c
            except:
                pass
        raise RuntimeError("TELEGRAM_TOKEN n√£o definido nas vari√°veis de ambiente ou secret file")
    TOKEN = _get_token()
    import re
    if not re.match(r"^\d+:[A-Za-z0-9_-]+$", TOKEN):
        raise RuntimeError("TELEGRAM_TOKEN inv√°lido. Verifique se copiou exatamente o token do @BotFather.")
    if not USE_SUPABASE:
        raise RuntimeError("SUPABASE_URL/SUPABASE_KEY n√£o definidos nas vari√°veis de ambiente")
    
    app = Application.builder().token(TOKEN).build()
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start), CommandHandler('producao', iniciar_producao), CommandHandler('consultar', comando_consultar), CallbackQueryHandler(button_callback)],
        states={
            AGUARDANDO_SA: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sa)],
            AGUARDANDO_GPON: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_gpon)],
            AGUARDANDO_FOTOS: [
                MessageHandler(filters.PHOTO, receber_foto),
                CommandHandler('finalizar', finalizar)
            ],
            AGUARDANDO_DATA_INICIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_inicio)],
            AGUARDANDO_DATA_FIM: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_fim)],
            AGUARDANDO_NOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_nome)],
            AGUARDANDO_SOBRENOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sobrenome)],
            AGUARDANDO_REGIAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_regiao)],
            AGUARDANDO_CONSULTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, consultar)],
        },
        fallbacks=[CommandHandler('cancelar', cancelar)]
    )
    
    app.add_handler(CommandHandler('mensal', comando_mensal))
    app.add_handler(CommandHandler('semanal', comando_semanal))
    app.add_handler(CommandHandler('hoje', comando_hoje))
    app.add_handler(conv_handler)
    
    base_url = os.getenv("WEBHOOK_BASE_URL") or os.getenv("RENDER_EXTERNAL_URL")
    if base_url:
        port = int(os.getenv("PORT", "10000"))
        url_path = TOKEN
        webhook_url = f"{base_url}/{url_path}"
        print('ü§ñ Bot iniciado (webhook)! Aguardando mensagens...')
        app.run_webhook(listen="0.0.0.0", port=port, url_path=url_path, webhook_url=webhook_url)
    else:
        print('ü§ñ Bot iniciado (polling)! Aguardando mensagens...')
        app.run_polling()

if __name__ == '__main__':
    main()