import os
from datetime import datetime, timedelta
from collections import defaultdict
import csv
import io
from zoneinfo import ZoneInfo
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, ContextTypes
from supabase import create_client
from keep_alive import keep_alive

# Estados da conversa
AGUARDANDO_SA, AGUARDANDO_GPON, AGUARDANDO_TIPO, AGUARDANDO_SERIAL, AGUARDANDO_SERIAL_MESH, AGUARDANDO_FOTOS, AGUARDANDO_DATA_INICIO, AGUARDANDO_DATA_FIM, AGUARDANDO_NOME, AGUARDANDO_SOBRENOME, AGUARDANDO_REGIAO, AGUARDANDO_CONSULTA, AGUARDANDO_BROADCAST, AGUARDANDO_CONFIRMACAO_BROADCAST = range(14)


TZ = ZoneInfo("America/Sao_Paulo")

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
USE_SUPABASE = bool(SUPABASE_URL and SUPABASE_KEY)
_SUPABASE_CLIENT = None

# Lista de IDs de administradores (adicione seu ID do Telegram aqui)
# Para descobrir seu ID, use o comando /meuid
ADMIN_IDS = [
    1797158471,  # Admin principal
]

PONTOS_SERVICO = {
    'defeito_banda_larga': 1.43,
    'defeito_linha': 1.43,
    'defeito_tv': 1.43,
    'instalacao': 2.28,
    'instalacao_tv': 3.58,
    'instalacao_mesh': 2.91,
    'mudanca_endereco': 2.37,
    'retirada': 1.06,
    'servicos': 1.50,
    'servico': 1.50
}

TABELA_FAIXAS = [
    {'min': 164.0, 'max': float('inf'), 'faixa': 'A', 'valor': 3.20, 'valor_turbo': 8.00},
    {'min': 159.0, 'max': 163.99, 'faixa': 'B', 'valor': 2.40, 'valor_turbo': 6.00},
    {'min': 148.0, 'max': 158.99, 'faixa': 'C', 'valor': 1.60, 'valor_turbo': 4.00},
    {'min': 137.0, 'max': 147.99, 'faixa': 'D', 'valor': 1.00, 'valor_turbo': 2.50},
    {'min': 126.0, 'max': 136.99, 'faixa': 'E', 'valor': 0.80, 'valor_turbo': 2.25},
    {'min': 120.0, 'max': 125.99, 'faixa': 'F', 'valor': 0.70, 'valor_turbo': 2.00},
    {'min': 115.0, 'max': 119.99, 'faixa': 'G', 'valor': 0.70, 'valor_turbo': 1.75},
    {'min': 109.0, 'max': 114.99, 'faixa': 'H', 'valor': 0.60, 'valor_turbo': 1.50},
    {'min': 0.0,   'max': 108.99, 'faixa': 'I', 'valor': 0.00, 'valor_turbo': 0.00}
]

def _formata_brl(v: float) -> str:
    s = f"{v:,.2f}"
    s = s.replace(',', 'X').replace('.', ',').replace('X', '.')
    return f"R$ {s}"

def calcular_pontos(instalacoes: list) -> float:
    total = 0.0
    for inst in instalacoes:
        tipo = str(inst.get('tipo') or 'instalacao').lower()
        total += PONTOS_SERVICO.get(tipo, 1.0)
    return total

def contar_dias_produtivos(instalacoes: list) -> int:
    dias = set()
    for inst in instalacoes:
        try:
            dt = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M')
            dias.add(dt.date())
        except:
            continue
    return len(dias)

def obter_faixa_valor(pontos: float):
    p = float(pontos)
    for tier in TABELA_FAIXAS:
        if tier['min'] <= p <= tier['max']:
            return tier
    return TABELA_FAIXAS[-1]

def ciclo_atual():
    agora = datetime.now(TZ)
    if agora.day >= 16:
        inicio = datetime(agora.year, agora.month, 16, tzinfo=TZ)
        ano = agora.year + 1 if agora.month == 12 else agora.year
        mes = 1 if agora.month == 12 else agora.month + 1
        fim = datetime(ano, mes, 15, 23, 59, tzinfo=TZ)
    else:
        ano_prev = agora.year - 1 if agora.month == 1 else agora.year
        mes_prev = 12 if agora.month == 1 else agora.month - 1
        inicio = datetime(ano_prev, mes_prev, 16, tzinfo=TZ)
        fim = datetime(agora.year, agora.month, 15, 23, 59, tzinfo=TZ)
    return inicio, fim

def montar_msg_producao(instalacoes_user: list, inicio: datetime, fim: datetime, username: str):
    dias_periodo = (fim - inicio).days + 1
    media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
    pontos = calcular_pontos(instalacoes_user)
    dias_produtivos = contar_dias_produtivos(instalacoes_user)
    turbo_ativo = dias_produtivos >= 24
    tier = obter_faixa_valor(pontos)
    valor_unit = tier['valor_turbo'] if turbo_ativo else tier['valor']
    valor_total = pontos * valor_unit
    
    # Encontrar prÃ³xima faixa
    proxima_faixa = None
    for t in reversed(TABELA_FAIXAS):
        if t['min'] > pontos:
            proxima_faixa = t
            break
            
    # Barra de progresso
    progresso_msg = ""
    if proxima_faixa:
        meta = proxima_faixa['min']
        falta = meta - pontos
        percentual = min(100, (pontos / meta) * 100)
        blocos = int(percentual / 10)
        barra = "â–ˆ" * blocos + "â–‘" * (10 - blocos)
        
        # Estimativa de instalaÃ§Ãµes faltantes (mÃ©dia 1.5 pts por inst)
        inst_faltantes = int(falta / 1.5) + 1
        
        progresso_msg = (
            f'\nğŸ¯ *PrÃ³xima Meta: Faixa {proxima_faixa["faixa"]}*\n'
            f'Progresso: `{barra}` {percentual:.1f}%\n'
            f'Faltam: *{falta:.2f} pontos* (~{inst_faltantes} inst.)\n'
        )
    else:
        progresso_msg = "\nğŸ† *ParabÃ©ns! VocÃª atingiu a faixa mÃ¡xima!*\n"

    msg = (
        f'ğŸ“† *ProduÃ§Ã£o no PerÃ­odo*\n'
        f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
        f'ğŸ‘¤ TÃ©cnico: {username}\n\n'
        f'ğŸ“Š *Resumo:*\n'
        f'â€¢ InstalaÃ§Ãµes: {len(instalacoes_user)}\n'
        f'â€¢ Pontos: *{pontos:.2f}*\n'
        f'â€¢ Dias Produtivos: {dias_produtivos}/24\n'
        f'â€¢ MÃ©dia DiÃ¡ria: {media_dia:.1f}\n'
        f'{progresso_msg}\n'
        f'ğŸ’° *Financeiro:*\n'
        f'â€¢ Faixa Atual: *{tier["faixa"]}*\n'
        f'â€¢ Modo Turbo: {"âœ… ATIVO" if turbo_ativo else "âŒ INATIVO"}\n'
        f'â€¢ Valor Ponto: {_formata_brl(valor_unit)}\n'
        f'â€¢ *Total Estimado: {_formata_brl(valor_total)}*\n'
    )
    return msg

def get_supabase():
    global _SUPABASE_CLIENT
    if not USE_SUPABASE:
        return None
    
    if _SUPABASE_CLIENT is None:
        import threading
        
        url = SUPABASE_URL or ""
        key = SUPABASE_KEY or ""
        
        # Check for common issues
        if '"' in url or "'" in url:
            print("âš ï¸ WARNING: Quotes detected in SUPABASE_URL! Remove them in Render dashboard.", flush=True)
        if ' ' in url:
            print("âš ï¸ WARNING: Spaces detected in SUPABASE_URL! Remove them.", flush=True)
            
        def connect():
            global _SUPABASE_CLIENT
            try:
                print(f"ğŸ”„ Connecting to Supabase (Thread)...", flush=True)
                _SUPABASE_CLIENT = create_client(url, key)
                print("âœ… Supabase client created (Thread).", flush=True)
            except Exception as e:
                print(f"âŒ Failed to create Supabase client: {e}", flush=True)

        # Run connection in a thread with timeout
        t = threading.Thread(target=connect)
        t.daemon = True
        t.start()
        t.join(timeout=10) # Wait 10 seconds max
        
        if t.is_alive():
            print("âŒ Timeout: Supabase connection took too long (>10s). Skipping.", flush=True)
            return None
            
    return _SUPABASE_CLIENT

def check_supabase_health():
    """Verifica se a conexÃ£o com o Supabase estÃ¡ funcionando"""
    print("ğŸ¥ Iniciando verificaÃ§Ã£o de saÃºde do Supabase...", flush=True)
    if not USE_SUPABASE:
        print("âŒ Supabase nÃ£o configurado (URL ou KEY ausentes).", flush=True)
        return False
    
    try:
        sb = get_supabase()
        if not sb:
            print("âŒ Cliente Supabase nÃ£o pÃ´de ser criado.", flush=True)
            return False
            
        # Tenta fazer uma query simples com timeout
        print("ğŸ”„ Testando query no Supabase...", flush=True)
        
        import threading
        result = {'success': False, 'resp': None, 'error': None}
        
        def run_query():
            try:
                # Usando count='exact' e head=True para ser mais leve
                result['resp'] = sb.table("instalacoes").select("count", count="exact").limit(1).execute()
                result['success'] = True
            except Exception as e:
                result['error'] = e

        t = threading.Thread(target=run_query)
        t.daemon = True
        t.start()
        t.join(timeout=10)
        
        if t.is_alive():
            print("âŒ Timeout: Query no Supabase demorou mais de 10s.", flush=True)
            return False
            
        if result['success']:
            print(f"âœ… ConexÃ£o Supabase OK! Resposta: {result['resp']}", flush=True)
            return True
        else:
            print(f"âŒ Erro na query do Supabase: {result['error']}", flush=True)
            return False
            
    except Exception as e:
        print(f"âŒ Erro na verificaÃ§Ã£o de saÃºde do Supabase: {e}", flush=True)
        return False

# Carregar dados existentes
def carregar_dados():
    try:
        sb = get_supabase()
        resp = sb.table("instalacoes").select("*").execute()
        data = resp.data or []
        return data
    except Exception as e:
        print(f"âŒ Erro ao carregar dados: {e}")
        return []

# Salvar dados


def carregar_usuarios():
    try:
        sb = get_supabase()
        resp = sb.table("usuarios").select("*").execute()
        rows = resp.data or []
        usuarios = {}
        for r in rows:
            uid = str(r.get('id'))
            usuarios[uid] = {
                'nome': r.get('nome') or '',
                'sobrenome': r.get('sobrenome') or '',
                'regiao': r.get('regiao'),
                'telegram': r.get('telegram')
            }
        return usuarios
    except Exception as e:
        print(f"âŒ Erro ao carregar usuÃ¡rios: {e}")
        return {}



def salvar_usuario(uid: str, dados_usuario: dict):
    try:
        sb = get_supabase()
        if not sb:
            print(f"âŒ Erro ao salvar usuÃ¡rio {uid}: Cliente Supabase nÃ£o disponÃ­vel.")
            return

        row = {
            'id': int(uid) if str(uid).isdigit() else str(uid),
            'nome': dados_usuario.get('nome') or '',
            'sobrenome': dados_usuario.get('sobrenome') or '',
            'regiao': dados_usuario.get('regiao'),
            'telegram': dados_usuario.get('telegram')
        }
        resp = sb.table("usuarios").upsert(row).execute()
        print(f"âœ… UsuÃ¡rio salvo com sucesso: {uid}")
    except Exception as e:
        print(f"âŒ Erro ao salvar usuÃ¡rio {uid}: {e}")
        print(f"Dados do usuÃ¡rio: {row}")

def salvar_instalacao(instalacao: dict) -> bool:
    try:
        sb = get_supabase()
        if not sb:
            print("âŒ Erro ao salvar instalaÃ§Ã£o: Cliente Supabase nÃ£o disponÃ­vel.")
            return False

        resp = sb.table("instalacoes").insert(instalacao).execute()
        ok = bool(resp.data)
        print(f"âœ… InstalaÃ§Ã£o salva com sucesso: SA {instalacao.get('sa', 'N/A')}")
        return ok
    except Exception as e:
        print(f"âŒ Erro ao salvar instalaÃ§Ã£o: {e}")
        print(f"Dados da instalaÃ§Ã£o: {instalacao}")
        return False

# Comando /ajuda
async def ajuda(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        'ğŸ†˜ *Central de Ajuda*\n\n'
        'Aqui estÃ£o os comandos disponÃ­veis:\n\n'
        'ğŸ”¹ /start - Iniciar o bot e ver o menu principal\n'
        'ğŸ”¹ /ajuda - Ver esta mensagem de ajuda\n'
        'ğŸ”¹ /cancelar - Cancelar a operaÃ§Ã£o atual\n'
        'ğŸ”¹ /meuid - Descobrir seu ID do Telegram\n'
        'ğŸ”¹ /mensal - RelatÃ³rio de produÃ§Ã£o mensal\n'
        'ğŸ”¹ /semanal - RelatÃ³rio de produÃ§Ã£o semanal\n'
        'ğŸ”¹ /hoje - RelatÃ³rio de produÃ§Ã£o de hoje\n'
        'ğŸ”¹ /consultar - Consultar uma instalaÃ§Ã£o por SA ou GPON\n'
        'ğŸ”¹ /reparo - Iniciar registro de reparo rÃ¡pido\n'
        'ğŸ”¹ /producao - Consultar produÃ§Ã£o por perÃ­odo\n\n'
        'ğŸ’¡ *Dica:* Se ficar preso em alguma etapa, digite /cancelar para voltar ao inÃ­cio.'
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /meuid - Descobre o ID do usuÃ¡rio
async def meu_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "NÃ£o definido"
    first_name = update.message.from_user.first_name
    
    msg = (
        f'ğŸ†” *Suas InformaÃ§Ãµes*\n\n'
        f'ğŸ‘¤ Nome: {first_name}\n'
        f'ğŸ”– Username: @{username}\n'
        f'ğŸ”¢ **ID do Telegram:** `{user_id}`\n\n'
        f'ğŸ’¡ *Para se tornar admin:*\n'
        f'Envie este ID para o administrador do sistema.\n'
        f'Ele deve adicionar `{user_id}` na lista `ADMIN_IDS`.'
    )
    
    await update.message.reply_text(msg, parse_mode='Markdown')

# ==================== PAINEL ADMIN ====================

def is_admin(user_id: int) -> bool:
    """Verifica se o usuÃ¡rio Ã© administrador"""
    return user_id in ADMIN_IDS

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Painel principal de administraÃ§Ã£o"""
    user_id = update.message.from_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text('âŒ Acesso negado. VocÃª nÃ£o tem permissÃ£o de administrador.')
        return
    
    keyboard = [
        [InlineKeyboardButton("ğŸ“Š EstatÃ­sticas Gerais", callback_data='admin_stats')],
        [InlineKeyboardButton("ğŸ‘¥ Listar TÃ©cnicos", callback_data='admin_users')],
        [InlineKeyboardButton("ğŸ“‹ Todas InstalaÃ§Ãµes", callback_data='admin_all_installs')],
        [InlineKeyboardButton("ğŸ“¢ Enviar Mensagem para Todos", callback_data='admin_broadcast')],
        [InlineKeyboardButton("ğŸ“¤ Exportar Dados", callback_data='admin_export')],
        [InlineKeyboardButton("ğŸ”§ Gerenciar Admins", callback_data='admin_manage')],
        [InlineKeyboardButton("ğŸ”™ Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
        'ğŸ‘‘ *PAINEL ADMINISTRATIVO*\n'
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
        'ğŸ” Acesso: Administrador\n'
        f'ğŸ“… {datetime.now(TZ).strftime("%d/%m/%Y %H:%M")}\n\n'
        'Selecione uma opÃ§Ã£o:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def admin_stats(query):
    """Mostra estatÃ­sticas gerais do sistema"""
    dados = carregar_dados()
    usuarios = carregar_usuarios()
    
    agora = datetime.now(TZ)
    mes_atual = agora.month
    ano_atual = agora.year
    
    # Calcular mÃªs anterior
    if mes_atual == 1:
        mes_anterior = 12
        ano_anterior = ano_atual - 1
    else:
        mes_anterior = mes_atual - 1
        ano_anterior = ano_atual
        
    # EstatÃ­sticas
    total_instalacoes = len(dados)
    total_tecnicos = len(usuarios)
    
    inst_mes_atual = 0
    inst_mes_anterior = 0
    por_regiao = defaultdict(int)
    
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            
            # Contagem por mÃªs
            if data_inst.month == mes_atual and data_inst.year == ano_atual:
                inst_mes_atual += 1
            elif data_inst.month == mes_anterior and data_inst.year == ano_anterior:
                inst_mes_anterior += 1
                
            # Contagem por regiÃ£o
            regiao = inst.get('tecnico_regiao') or 'NÃ£o informada'
            por_regiao[regiao] += 1
        except:
            continue
            
    # Calcular crescimento
    crescimento = 0
    if inst_mes_anterior > 0:
        crescimento = ((inst_mes_atual - inst_mes_anterior) / inst_mes_anterior) * 100
    
    sinal = "+" if crescimento >= 0 else ""
    
    # Top RegiÃµes
    top_regioes = sorted(por_regiao.items(), key=lambda x: x[1], reverse=True)[:3]
    
    msg = (
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
        'ğŸ“Š *ESTATÃSTICAS AVANÃ‡ADAS*\n'
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
        f'ğŸ‘¥ *TÃ©cnicos:* {total_tecnicos}\n'
        f'ğŸ“¦ *Total Geral:* {total_instalacoes}\n\n'
        'ğŸ“… *Comparativo Mensal*\n'
        f'â€¢ Este MÃªs: *{inst_mes_atual}*\n'
        f'â€¢ MÃªs Passado: *{inst_mes_anterior}*\n'
        f'ğŸ“ˆ Crescimento: *{sinal}{crescimento:.1f}%*\n\n'
        'ğŸ† *Top RegiÃµes*\n'
    )
    
    for idx, (regiao, qtd) in enumerate(top_regioes, 1):
        barra = "â–ˆ" * min(int(qtd/5) + 1, 10)
        msg += f'{idx}. {regiao}: *{qtd}* ({barra})\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_list_users(query):
    """Lista todos os tÃ©cnicos cadastrados"""
    usuarios = carregar_usuarios()
    dados = carregar_dados()
    
    # Contar instalaÃ§Ãµes por tÃ©cnico
    instalacoes_por_tecnico = defaultdict(int)
    for inst in dados:
        tecnico_id = str(inst.get('tecnico_id', ''))
        if tecnico_id:
            instalacoes_por_tecnico[tecnico_id] += 1
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = (
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
        f'ğŸ‘¥ *TÃ‰CNICOS ({len(usuarios)})*\n'
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
    )
    
    # Ordenar por nÃºmero de instalaÃ§Ãµes
    lista_ordenada = sorted(usuarios.items(), key=lambda x: instalacoes_por_tecnico.get(x[0], 0), reverse=True)
    
    # PaginaÃ§Ã£o simples (top 20)
    for user_id, dados_user in lista_ordenada[:20]:
        nome_completo = f"{dados_user.get('nome', '')} {dados_user.get('sobrenome', '')}".strip()
        regiao = dados_user.get('regiao', 'N/A')
        qtd = instalacoes_por_tecnico.get(user_id, 0)
        uid_int = int(user_id) if str(user_id).isdigit() else None
        is_adm = 'ğŸ‘‘ ' if (uid_int is not None and uid_int in ADMIN_IDS) else ''
        
        msg += f'{is_adm}*{escape_md(nome_completo)}*\n'
        msg += f'ğŸ†” `{user_id}` | ğŸ“ {escape_md(regiao)}\n'
        msg += f'ğŸ“¦ {qtd} instalaÃ§Ãµes\n'
        msg += 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n'
        
    if len(lista_ordenada) > 20:
        msg += f'\n_E mais {len(lista_ordenada) - 20} tÃ©cnicos..._'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_all_installations(query):
    """Lista todas as instalaÃ§Ãµes recentes"""
    dados = carregar_dados()
    
    # Pegar as Ãºltimas 20 instalaÃ§Ãµes
    ultimas = dados[-20:] if len(dados) > 20 else dados
    ultimas.reverse()  # Mais recentes primeiro
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = f'ğŸ“‹ *Ãšltimas InstalaÃ§Ãµes ({len(ultimas)}/{len(dados)})*\n\n'
    
    for inst in ultimas:
        msg += f'ğŸ“… {escape_md(inst["data"])}\n'
        msg += f'SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
        msg += f'ğŸ‘¤ {escape_md(inst["tecnico_nome"])}\n'
        msg += f'ğŸ§© {escape_md(inst.get("tipo", "instalacao"))}\n\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_export_data(query):
    """Exporta dados em formato CSV"""
    await query.edit_message_text('â³ Gerando arquivo CSV, aguarde...')
    
    dados = carregar_dados()
    
    if not dados:
        await query.edit_message_text('âŒ NÃ£o hÃ¡ dados para exportar.')
        return

    # Criar buffer em memÃ³ria
    output = io.StringIO()
    writer = csv.writer(output)
    
    # CabeÃ§alho
    writer.writerow(['Data', 'SA', 'GPON', 'Tipo', 'Categoria', 'TÃ©cnico', 'RegiÃ£o', 'Serial Modem', 'Serial Mesh'])
    
    # Dados
    for inst in dados:
        writer.writerow([
            inst.get('data', ''),
            inst.get('sa', ''),
            inst.get('gpon', ''),
            inst.get('tipo', ''),
            inst.get('categoria', ''),
            inst.get('tecnico_nome', ''),
            inst.get('tecnico_regiao', ''),
            inst.get('serial_modem', ''),
            inst.get('serial_mesh', '')
        ])
    
    # Preparar arquivo para envio
    output.seek(0)
    csv_bytes = output.getvalue().encode('utf-8-sig') # BOM para Excel abrir direito
    
    agora_str = datetime.now(TZ).strftime('%Y-%m-%d_%H-%M')
    filename = f'instalacoes_{agora_str}.csv'
    
    try:
        await query.message.reply_document(
            document=csv_bytes,
            filename=filename,
            caption=f'ğŸ“Š *ExportaÃ§Ã£o Completa*\nğŸ“… {datetime.now(TZ).strftime("%d/%m/%Y %H:%M")}\nğŸ“¦ Total: {len(dados)} registros',
            parse_mode='Markdown'
        )
        # Restaurar menu
        await admin_panel(query, None) # Gambiarra para voltar ao menu, ideal seria mandar mensagem separada
    except Exception as e:
        await query.edit_message_text(f'âŒ Erro ao enviar arquivo: {str(e)}')

async def admin_manage_admins(query):
    """Gerenciar administradores"""
    msg = (
        'ğŸ”§ *Gerenciar Administradores*\n\n'
        f'Admins atuais: {len(ADMIN_IDS)}\n\n'
        'ğŸ“ Para adicionar/remover admins:\n'
        '1. Edite o arquivo `tecnico_bot`\n'
        '2. Encontre a lista `ADMIN_IDS`\n'
        '3. Adicione ou remova IDs\n'
        '4. FaÃ§a deploy novamente\n\n'
        'ğŸ’¡ *Como descobrir um ID:*\n'
        'Use o comando /meuid ou\n'
        'PeÃ§a para o usuÃ¡rio enviar /start\n'
        'O ID aparecerÃ¡ nos logs do Render'
    )
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_broadcast_start(query):
    """Inicia o processo de broadcast"""
    msg = (
        'ğŸ“¢ *Enviar Mensagem para Todos*\n\n'
        'ğŸ“ Envie a mensagem que deseja transmitir para todos os tÃ©cnicos cadastrados.\n\n'
        'ğŸ’¡ *VocÃª pode enviar:*\n'
        'â€¢ Texto simples\n'
        'â€¢ ğŸ“· Foto com legenda\n'
        'â€¢ ğŸ¥ VÃ­deo com legenda\n'
        'â€¢ ğŸ“„ Documento com legenda\n\n'
        'âœ¨ *Recursos:*\n'
        'â€¢ Use Markdown para formataÃ§Ã£o de texto\n'
        'â€¢ OpÃ§Ã£o de fixar a mensagem nos chats\n'
        'â€¢ Preview antes de enviar\n\n'
        'âš ï¸ Digite /cancelar para cancelar o envio.'
    )
    await query.edit_message_text(msg, parse_mode='Markdown')
    return AGUARDANDO_BROADCAST


async def admin_send_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Recebe a mensagem broadcast (texto ou mÃ­dia) e mostra preview com opÃ§Ãµes"""
    user_id = update.message.from_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text('âŒ Acesso negado.')
        return ConversationHandler.END
    
    # Detectar tipo de mensagem e armazenar dados
    broadcast_data = {}
    
    if update.message.photo:
        # Foto com legenda
        broadcast_data['type'] = 'photo'
        broadcast_data['file_id'] = update.message.photo[-1].file_id  # Maior resoluÃ§Ã£o
        broadcast_data['caption'] = update.message.caption or ''
        preview_type = 'ğŸ“· Foto'
    elif update.message.video:
        # VÃ­deo com legenda
        broadcast_data['type'] = 'video'
        broadcast_data['file_id'] = update.message.video.file_id
        broadcast_data['caption'] = update.message.caption or ''
        preview_type = 'ğŸ¥ VÃ­deo'
    elif update.message.document:
        # Documento com legenda
        broadcast_data['type'] = 'document'
        broadcast_data['file_id'] = update.message.document.file_id
        broadcast_data['caption'] = update.message.caption or ''
        preview_type = 'ğŸ“„ Documento'
    elif update.message.text:
        # Texto simples
        broadcast_data['type'] = 'text'
        broadcast_data['text'] = update.message.text.strip()
        preview_type = 'ğŸ“ Texto'
    else:
        await update.message.reply_text('âŒ Tipo de mensagem nÃ£o suportado. Use texto, foto, vÃ­deo ou documento.')
        return AGUARDANDO_BROADCAST
    
    # Armazenar dados no contexto
    context.user_data['broadcast_data'] = broadcast_data
    
    # Mostrar preview e opÃ§Ãµes
    usuarios = carregar_usuarios()
    total_usuarios = len(usuarios)
    
    # Preparar preview da mensagem
    if broadcast_data['type'] == 'text':
        preview_content = broadcast_data['text'][:200]
        if len(broadcast_data['text']) > 200:
            preview_content += '...'
    else:
        preview_content = broadcast_data.get('caption', '(sem legenda)')[:200]
        if len(broadcast_data.get('caption', '')) > 200:
            preview_content += '...'
    
    preview_msg = (
        f'ğŸ“‹ *Preview da Mensagem*\n\n'
        f'Tipo: {preview_type}\n'
        f'DestinatÃ¡rios: {total_usuarios} tÃ©cnicos\n\n'
        f'*ConteÃºdo:*\n{preview_content}\n\n'
        f'Escolha uma opÃ§Ã£o:'
    )
    
    # BotÃµes de confirmaÃ§Ã£o
    keyboard = [
        [InlineKeyboardButton("âœ… Enviar", callback_data='broadcast_send')],
        [InlineKeyboardButton("ğŸ“Œ Enviar e Fixar", callback_data='broadcast_send_pin')],
        [InlineKeyboardButton("âŒ Cancelar", callback_data='broadcast_cancel')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(preview_msg, reply_markup=reply_markup, parse_mode='Markdown')
    return AGUARDANDO_CONFIRMACAO_BROADCAST

async def confirmar_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Executa o broadcast apÃ³s confirmaÃ§Ã£o do admin"""
    query = update.callback_query
    user_id = query.from_user.id
    
    if not is_admin(user_id):
        await query.answer('âŒ Acesso negado', show_alert=True)
        return ConversationHandler.END
    
    await query.answer()
    
    # Verificar se Ã© cancelamento
    if query.data == 'broadcast_cancel':
        await query.edit_message_text('âŒ Broadcast cancelado.')
        context.user_data.pop('broadcast_data', None)
        return ConversationHandler.END
    
    # Verificar se deve fixar
    pin_message = query.data == 'broadcast_send_pin'
    
    # Recuperar dados do broadcast
    broadcast_data = context.user_data.get('broadcast_data')
    if not broadcast_data:
        await query.edit_message_text('âŒ Erro: dados do broadcast nÃ£o encontrados.')
        return ConversationHandler.END
    
    usuarios = carregar_usuarios()
    
    if not usuarios:
        await query.edit_message_text('âŒ Nenhum tÃ©cnico cadastrado para enviar mensagem.')
        return ConversationHandler.END
    
    # Atualizar mensagem para mostrar progresso
    await query.edit_message_text('ğŸ“¤ Enviando mensagem para todos os tÃ©cnicos...')
    
    # Preparar cabeÃ§alho
    header = 'ğŸ“¢ *AVISO DA ADMINISTRAÃ‡ÃƒO*\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
    footer = '\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”'
    
    # Enviar para todos os usuÃ¡rios
    enviados = 0
    falhas = 0
    fixados = 0
    
    for uid in usuarios.keys():
        try:
            message_sent = None
            
            if broadcast_data['type'] == 'text':
                # Texto simples
                mensagem_completa = header + broadcast_data['text'] + footer
                message_sent = await context.bot.send_message(
                    chat_id=int(uid),
                    text=mensagem_completa,
                    parse_mode='Markdown'
                )
            elif broadcast_data['type'] == 'photo':
                # Foto com legenda
                caption = header + broadcast_data['caption'] + footer if broadcast_data['caption'] else header.strip()
                message_sent = await context.bot.send_photo(
                    chat_id=int(uid),
                    photo=broadcast_data['file_id'],
                    caption=caption,
                    parse_mode='Markdown'
                )
            elif broadcast_data['type'] == 'video':
                # VÃ­deo com legenda
                caption = header + broadcast_data['caption'] + footer if broadcast_data['caption'] else header.strip()
                message_sent = await context.bot.send_video(
                    chat_id=int(uid),
                    video=broadcast_data['file_id'],
                    caption=caption,
                    parse_mode='Markdown'
                )
            elif broadcast_data['type'] == 'document':
                # Documento com legenda
                caption = header + broadcast_data['caption'] + footer if broadcast_data['caption'] else header.strip()
                message_sent = await context.bot.send_document(
                    chat_id=int(uid),
                    document=broadcast_data['file_id'],
                    caption=caption,
                    parse_mode='Markdown'
                )
            
            enviados += 1
            
            # Fixar mensagem se solicitado
            if pin_message and message_sent:
                try:
                    await context.bot.pin_chat_message(
                        chat_id=int(uid),
                        message_id=message_sent.message_id,
                        disable_notification=True
                    )
                    fixados += 1
                except Exception as pin_error:
                    print(f"Erro ao fixar mensagem para {uid}: {pin_error}")
                    
        except Exception as e:
            falhas += 1
            print(f"Erro ao enviar para {uid}: {e}")
    
    # RelatÃ³rio de envio
    relatorio = (
        f'âœ… *Broadcast ConcluÃ­do!*\n\n'
        f'ğŸ“Š *EstatÃ­sticas:*\n'
        f'âœ… Enviados: {enviados}\n'
        f'âŒ Falhas: {falhas}\n'
        f'ğŸ‘¥ Total de tÃ©cnicos: {len(usuarios)}\n'
    )
    
    if pin_message:
        relatorio += f'ğŸ“Œ Mensagens fixadas: {fixados}\n'
    
    relatorio += '\nğŸ’¡ Falhas podem ocorrer se o usuÃ¡rio bloqueou o bot.'
    
    await query.edit_message_text(relatorio, parse_mode='Markdown')
    
    # Limpar dados
    context.user_data.pop('broadcast_data', None)
    
    return ConversationHandler.END


async def admin_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para callbacks do painel admin"""
    query = update.callback_query
    user_id = query.from_user.id
    
    if not is_admin(user_id):
        await query.answer('âŒ Acesso negado', show_alert=True)
        return ConversationHandler.END
    
    await query.answer()
    
    if query.data == 'admin_stats':
        await admin_stats(query)
        return None
    elif query.data == 'admin_users':
        await admin_list_users(query)
        return None
    elif query.data == 'admin_all_installs':
        await admin_all_installations(query)
        return None
    elif query.data == 'admin_broadcast':
        return await admin_broadcast_start(query)
    elif query.data == 'admin_export':
        await admin_export_data(query)
        return None
    elif query.data == 'admin_manage':
        await admin_manage_admins(query)
        return None

# ==================== FIM PAINEL ADMIN ====================

# Comando /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    print(f"ğŸ” User ID: {user_id} | Username: {username}")  # Log para descobrir IDs
    
    usuarios = carregar_usuarios()
    if str(user_id) not in usuarios:
        context.user_data['ident'] = {}
        await update.message.reply_text(
            'ğŸ‘‹ *Bem-vindo ao TÃ‰CNICO BOT!*\n\n'
            'Para comeÃ§ar, vamos configurar seu perfil.\n\n'
            'ğŸ“ Por favor, informe seu *primeiro nome*:\n'
            '_(Digite /cancelar a qualquer momento para sair)_'
        )
        return AGUARDANDO_NOME
    keyboard = [
        [InlineKeyboardButton("ğŸ†• Registrar InstalaÃ§Ã£o", callback_data='registrar')],
        [InlineKeyboardButton("ğŸ› ï¸ Registrar Reparo", callback_data='registrar_reparo')],
        [InlineKeyboardButton("ğŸ” Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("ğŸ“‚ Minhas InstalaÃ§Ãµes", callback_data='minhas')],
        [InlineKeyboardButton("ğŸ“… Consulta ProduÃ§Ã£o", callback_data='consulta_producao')],
        [InlineKeyboardButton("ğŸ“Š RelatÃ³rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
        'ğŸ› ï¸ *TÃ‰CNICO BOT*\n'
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
        f'ğŸ‘‹ OlÃ¡, *{username}*!\n'
        f'ğŸ“… {datetime.now(TZ).strftime("%d/%m/%Y")}\n\n'
        'Escolha uma opÃ§Ã£o abaixo:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    return ConversationHandler.END

async def receber_nome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['nome'] = update.message.text.strip()
    await update.message.reply_text(
        'ğŸ“ Ã“timo! Agora informe seu *sobrenome*:\n'
        '_(Ou /cancelar para sair)_'
    )
    return AGUARDANDO_SOBRENOME

async def receber_sobrenome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['sobrenome'] = update.message.text.strip()
    await update.message.reply_text(
        'ğŸ“ Para finalizar, informe sua *regiÃ£o de atuaÃ§Ã£o*:\n'
        '_(Ou /cancelar para sair)_'
    )
    return AGUARDANDO_REGIAO

async def receber_regiao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    regiao = update.message.text.strip()
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
    ident = context.user_data.get('ident', {})
    dados_usuario = {
        'nome': ident.get('nome', ''),
        'sobrenome': ident.get('sobrenome', ''),
        'regiao': regiao,
        'telegram': update.message.from_user.username or update.message.from_user.first_name
    }
    usuarios[str(user_id)] = dados_usuario
    salvar_usuario(str(user_id), dados_usuario)
    keyboard = [
        [InlineKeyboardButton("ğŸ†• Registrar InstalaÃ§Ã£o", callback_data='registrar')],
        [InlineKeyboardButton("ğŸ› ï¸ Registrar Reparo", callback_data='registrar_reparo')],
        [InlineKeyboardButton("ğŸ” Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("ğŸ“‚ Minhas InstalaÃ§Ãµes", callback_data='minhas')],
        [InlineKeyboardButton("ğŸ“… Consulta ProduÃ§Ã£o", callback_data='consulta_producao')],
        [InlineKeyboardButton("ğŸ“Š RelatÃ³rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'âœ… Perfil salvo!\n\nAgora vocÃª pode usar o menu:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    context.user_data.pop('ident', None)
    return ConversationHandler.END

# Menu de relatÃ³rios
async def menu_relatorios(query):
    keyboard = [
        [InlineKeyboardButton("ğŸ“… RelatÃ³rio Mensal", callback_data='rel_mensal')],
        [InlineKeyboardButton("ğŸ“Š RelatÃ³rio Semanal", callback_data='rel_semanal')],
        [InlineKeyboardButton("ğŸ“† RelatÃ³rio por PerÃ­odo", callback_data='rel_periodo')],
        [InlineKeyboardButton("ğŸ“ˆ RelatÃ³rio Hoje", callback_data='rel_hoje')],
        [InlineKeyboardButton("ğŸ† Ranking TÃ©cnicos", callback_data='rel_ranking')],
        [InlineKeyboardButton("ğŸ”™ Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        'ğŸ“Š *RelatÃ³rios DisponÃ­veis*\n\n'
        'Escolha o tipo de relatÃ³rio:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Gerar relatÃ³rio mensal
def gerar_relatorio_mensal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    mes_atual = agora.month
    ano_atual = agora.year
    
    # Filtrar instalaÃ§Ãµes do mÃªs atual
    instalacoes_mes = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.month == mes_atual and data_inst.year == ano_atual:
                instalacoes_mes.append(inst)
        except:
            continue
    
    if not instalacoes_mes:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada neste mÃªs."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_mes:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    nome_mes = agora.strftime('%B/%Y')
    msg = (
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
        'ğŸ“… *RELATÃ“RIO MENSAL*\n'
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
        f'ğŸ“† PerÃ­odo: *{nome_mes}*\n'
        f'ğŸ“Š Total: *{len(instalacoes_mes)} instalaÃ§Ãµes*\n\n'
        'ğŸ‘¥ *Por TÃ©cnico:*\n'
    )
    
    # Ordenar por quantidade (maior para menor)
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    # MÃ©dia diÃ¡ria
    dias_mes = agora.day
    media_dia = len(instalacoes_mes) / dias_mes
    msg += f'\nğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia'
    
    return msg

# Gerar relatÃ³rio semanal
def gerar_relatorio_semanal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    inicio_semana = agora - timedelta(days=agora.weekday())
    inicio_semana = inicio_semana.replace(hour=0, minute=0, second=0, microsecond=0)
    
    # Filtrar instalaÃ§Ãµes da semana
    instalacoes_semana = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst >= inicio_semana:
                instalacoes_semana.append(inst)
        except:
            continue
    
    if not instalacoes_semana:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada nesta semana."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_semana:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = (
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
        'ğŸ“Š *RELATÃ“RIO SEMANAL*\n'
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
        f'ğŸ“† PerÃ­odo: {inicio_semana.strftime("%d/%m")} a {agora.strftime("%d/%m/%Y")}\n'
        f'ğŸ“Š Total: *{len(instalacoes_semana)} instalaÃ§Ãµes*\n\n'
        'ğŸ‘¥ *Por TÃ©cnico:*\n'
    )
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    # MÃ©dia diÃ¡ria da semana
    dias_semana = (agora - inicio_semana).days + 1
    media_dia = len(instalacoes_semana) / dias_semana
    msg += f'\nğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia'
    
    return msg

# Gerar relatÃ³rio do dia
def gerar_relatorio_hoje():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    
    # Filtrar instalaÃ§Ãµes de hoje
    instalacoes_hoje = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.date() == agora.date():
                instalacoes_hoje.append(inst)
        except:
            continue
    
    if not instalacoes_hoje:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada hoje."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_hoje:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = (
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
        'ğŸ“ˆ *RELATÃ“RIO DE HOJE*\n'
        'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
        f'ğŸ“… Data: *{agora.strftime("%d/%m/%Y")}*\n'
        f'ğŸ“Š Total: *{len(instalacoes_hoje)} instalaÃ§Ãµes*\n\n'
        'ğŸ‘¥ *Por TÃ©cnico:*\n'
    )
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    return msg

# Gerar ranking geral
def gerar_ranking_tecnicos():
    dados = carregar_dados()
    
    if not dados:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada ainda."
    
    # Contar por tÃ©cnico (todos os tempos)
    por_tecnico = defaultdict(int)
    for inst in dados:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = f'ğŸ† *Ranking Geral de TÃ©cnicos*\n\n'
    msg += f'ğŸ“Š *Total Geral:* {len(dados)} instalaÃ§Ãµes\n\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    
    medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰']
    for idx, (tecnico, quantidade) in enumerate(tecnicos_ordenados, 1):
        medal = medals[idx-1] if idx <= 3 else f'{idx}Âº'
        percentual = (quantidade / len(dados)) * 100
        msg += f'{medal} *{tecnico}*\n'
        msg += f'   {quantidade} instalaÃ§Ãµes ({percentual:.1f}%)\n\n'
    
    return msg

# Callback dos botÃµes
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'registrar':
        context.user_data['modo_registro'] = 'instalacao'
        await query.edit_message_text(
            'ğŸ“ *Nova InstalaÃ§Ã£o* [Etapa 1/5]\n\n'
            'Digite o *nÃºmero da SA*:\n'
            'ğŸ’¡ Exemplo: 12345678\n\n'
            '_(Digite /cancelar para voltar ao menu)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'registrar_reparo':
        context.user_data['modo_registro'] = 'reparo'
        await query.edit_message_text(
        await query.edit_message_text(
            'ğŸ› ï¸ *Novo Reparo* [Etapa 1/5]\n\n'
            'Digite o *nÃºmero da SA*:\n'
            'ğŸ’¡ Exemplo: 12345678\n\n'
            '_(Digite /cancelar para voltar ao menu)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'consultar':
        await query.edit_message_text(
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
            'ï¿½ *CONSULTAR INSTALAÃ‡ÃƒO*\n'
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
            'Digite o *nÃºmero da SA* ou *GPON*:\n\n'
            'ğŸ’¡ Exemplos:\n'
            'â€¢ SA: 12345678\n'
            'â€¢ GPON: ABCD1234\n\n'
            'ğŸ” A busca Ã© automÃ¡tica e encontra resultados parciais',
            parse_mode='Markdown'
        )
        return AGUARDANDO_CONSULTA

    elif query.data == 'consulta_producao':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        inicio_dt, fim_dt = ciclo_atual()
        instalacoes_user = []
        for d in dados:
            try:
                data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
                if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                    instalacoes_user.append(d)
            except:
                continue
        if not instalacoes_user:
            msg = f'âŒ Nenhuma instalaÃ§Ã£o entre {inicio_dt.strftime("%d/%m/%Y")} e {fim_dt.strftime("%d/%m/%Y")}.'
            await query.edit_message_text(msg, parse_mode='Markdown')
            return None
        msg = montar_msg_producao(instalacoes_user, inicio_dt, fim_dt, username)
        
        keyboard = [[InlineKeyboardButton("ğŸ“„ Ver Detalhes", callback_data='detalhes_producao')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(msg, parse_mode='Markdown', reply_markup=reply_markup)
        return None
    
    elif query.data == 'detalhes_producao':
        dados = carregar_dados()
        user_id = query.from_user.id
        inicio_dt, fim_dt = ciclo_atual()
        
        instalacoes_user = []
        for d in dados:
            try:
                data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
                if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                    instalacoes_user.append(d)
            except:
                continue
                
        if not instalacoes_user:
            await query.answer("Nenhuma instalaÃ§Ã£o encontrada.", show_alert=True)
            return None
            
        # Gerar arquivo de texto ou mensagem longa
        msg = f"ğŸ“„ *Detalhes do Ciclo ({inicio_dt.strftime('%d/%m')} - {fim_dt.strftime('%d/%m')})*\n\n"
        for inst in sorted(instalacoes_user, key=lambda x: datetime.strptime(x['data'], '%d/%m/%Y %H:%M'), reverse=True):
            tipo = inst.get('tipo', 'InstalaÃ§Ã£o')
            pontos = PONTOS_SERVICO.get(tipo.lower(), 0)
            msg += f"ğŸ“… {inst['data']} | {pontos} pts\n"
            msg += f"ğŸ”§ {tipo} | SA: {inst['sa']}\n"
            msg += f"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
            
        # Se a mensagem for muito longa, cortar
        if len(msg) > 4000:
            msg = msg[:4000] + "\n\n(Lista truncada devido ao tamanho...)"
            
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'minhas':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        
        instalacoes_user = [d for d in dados if d.get('tecnico_id') == user_id]
        
        if not instalacoes_user:
            await query.edit_message_text('VocÃª ainda nÃ£o registrou nenhuma instalaÃ§Ã£o.')
            return None
        
        msg = f'ğŸ“‚ *Suas InstalaÃ§Ãµes ({len(instalacoes_user)})*\n\n'
        for i, inst in enumerate(instalacoes_user[-10:], 1):  # Ãšltimas 10
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
        
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'relatorios':
        await menu_relatorios(query)
        return None
    
    elif query.data == 'rel_mensal':
        msg = gerar_relatorio_mensal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_semanal':
        msg = gerar_relatorio_semanal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_hoje':
        msg = gerar_relatorio_hoje()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_periodo':
        await query.edit_message_text(
            'ğŸ“† *RelatÃ³rio por PerÃ­odo*\n\nEnvie a *data inicial* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para voltar)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_DATA_INICIO
    
    elif query.data == 'rel_ranking':
        msg = gerar_ranking_tecnicos()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    # Callbacks do painel admin
    elif query.data.startswith('admin_'):
        return await admin_callback_handler(update, context)
    
    elif query.data == 'voltar':
        keyboard = [
            [InlineKeyboardButton("ğŸ†• Registrar InstalaÃ§Ã£o", callback_data='registrar')],
            [InlineKeyboardButton("ğŸ› ï¸ Registrar Reparo", callback_data='registrar_reparo')],
            [InlineKeyboardButton("ğŸ” Consultar SA/GPON", callback_data='consultar')],
            [InlineKeyboardButton("ğŸ“‚ Minhas InstalaÃ§Ãµes", callback_data='minhas')],
            [InlineKeyboardButton("ğŸ“… Consulta ProduÃ§Ã£o", callback_data='consulta_producao')],
            [InlineKeyboardButton("ğŸ“Š RelatÃ³rios", callback_data='relatorios')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
            'ğŸ› ï¸ *TÃ‰CNICO BOT*\n'
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
            'Bem-vindo! Escolha uma opÃ§Ã£o:',
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        return None

# Receber nÃºmero da SA
async def receber_sa(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sa = update.message.text.strip()
    # ValidaÃ§Ã£o removida a pedido do usuÃ¡rio
    context.user_data['sa'] = sa
    await update.message.reply_text(
        f'âœ… *SA Registrada com Sucesso!*\n'
        f'ğŸ“‹ SA: `{sa}`\n\n'
        f'ğŸ“ [Etapa 2/5]\n'
        f'Agora digite o *GPON*:\n'
        f'ğŸ’¡ Exemplo: ABCD1234\n\n'
        f'_(Digite /cancelar para voltar)_',
        parse_mode='Markdown'
    )
    return AGUARDANDO_GPON

# Receber GPON
async def receber_gpon(update: Update, context: ContextTypes.DEFAULT_TYPE):
    gpon = update.message.text.strip()
    # ValidaÃ§Ã£o removida a pedido do usuÃ¡rio
    context.user_data['gpon'] = gpon
    context.user_data['fotos'] = []
    modo = context.user_data.get('modo_registro') or 'instalacao'
    if modo == 'reparo':
        keyboard = [
            [InlineKeyboardButton('Defeito Banda Larga', callback_data='defeito_banda_larga')],
            [InlineKeyboardButton('Defeito Linha', callback_data='defeito_linha')],
            [InlineKeyboardButton('Defeito TV', callback_data='defeito_tv')],
            [InlineKeyboardButton('MudanÃ§a de EndereÃ§o', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('Retirada', callback_data='retirada')],
            [InlineKeyboardButton('ServiÃ§os', callback_data='servicos')]
        ]
        prompt = (
        'âœ… *GPON Registrado!*\n'
        f'ğŸ”Œ GPON: `{gpon}`\n\n'
        'ğŸ“ [Etapa 3/5]\n'
        'Selecione o *tipo de reparo*:'
    )
    else:
        keyboard = [
            [InlineKeyboardButton('InstalaÃ§Ã£o', callback_data='instalacao')],
            [InlineKeyboardButton('InstalaÃ§Ã£o TV', callback_data='instalacao_tv')],
            [InlineKeyboardButton('InstalaÃ§Ã£o + Mesh', callback_data='instalacao_mesh')],
            [InlineKeyboardButton('MudanÃ§a de EndereÃ§o', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('ServiÃ§os', callback_data='servicos')]
        ]
        prompt = (
        'âœ… *GPON Registrado!*\n'
        f'ğŸ”Œ GPON: `{gpon}`\n\n'
        'ğŸ“ [Etapa 3/5]\n'
        'Selecione o *tipo de serviÃ§o*:'
    )
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(prompt, reply_markup=reply_markup, parse_mode='Markdown')
    return AGUARDANDO_TIPO

# Receber fotos
async def receber_foto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'fotos' not in context.user_data:
        context.user_data['fotos'] = []
    
    # Pega a foto de maior resoluÃ§Ã£o
    photo = update.message.photo[-1]
    file_id = photo.file_id
    context.user_data['fotos'].append(file_id)
    
    num_fotos = len(context.user_data['fotos'])
    
    if num_fotos < 3:
        await update.message.reply_text(
            f'âœ… *Foto Recebida!*\n\n'
            f'ğŸ“¸ Progresso: {num_fotos}/3 fotos\n'
            f'{"ğŸŸ¢" * num_fotos}{"âšª" * (3-num_fotos)}\n\n'
            f'ğŸ“¤ Envie mais {3 - num_fotos} foto(s)\n'
            'ğŸ’¡ Digite /finalizar se jÃ¡ enviou todas.',
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            f'âœ… *Todas as fotos recebidas!*\n\n'
            f'ğŸ“¸ Progresso: {num_fotos}/3 fotos\n'
            f'{"ğŸŸ¢" * 3}\n\n'
            'âœ¨ Tudo pronto!\n'
            'Digite /finalizar para salvar a instalaÃ§Ã£o.',
            parse_mode='Markdown'
        )
    
    return AGUARDANDO_FOTOS

async def receber_tipo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tipo = query.data
    context.user_data['tipo'] = tipo
    
    # Verificar se precisa do Serial do Modem
    tipos_com_serial = ['instalacao', 'instalacao_tv', 'instalacao_mesh', 'mudanca_endereco', 'defeito_banda_larga', 'defeito_linha', 'defeito_tv']
    
    if tipo in tipos_com_serial:
        await query.edit_message_text(
            'âœ… *Tipo Selecionado!*\n\n'
            'ï¿½ [Etapa 4/5]\n'
            'Agora envie o *NÃºmero de SÃ©rie do Modem*:\n'
            'ğŸ’¡ Exemplo: ZTEGC8...\n\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SERIAL
    else:
        await query.edit_message_text(
            'âœ… *Tipo Selecionado!*\n\n'
            'ï¿½ [Etapa 5/5]\n'
            'Agora envie as *3 fotos* da instalaÃ§Ã£o.\n'
            'ğŸ’¡ Tire fotos claras do equipamento e instalaÃ§Ã£o\n\n'
            'Quando terminar, digite /finalizar',
            parse_mode='Markdown'
        )
        return AGUARDANDO_FOTOS
    return AGUARDANDO_FOTOS

# Finalizar registro
async def finalizar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'sa' not in context.user_data or 'gpon' not in context.user_data:
        await update.message.reply_text('âŒ Erro: Dados incompletos. Use /start para comeÃ§ar novamente.')
        return ConversationHandler.END
    
    usuarios = carregar_usuarios()
    uid = str(update.message.from_user.id)
    perfil = usuarios.get(uid)
    tecnico_nome = (f"{perfil.get('nome','')} {perfil.get('sobrenome','')}".strip() if perfil else (update.message.from_user.username or update.message.from_user.first_name))
    tecnico_regiao = (perfil.get('regiao') if perfil else None)
    
    nova_instalacao = {
        'sa': context.user_data['sa'],
        'gpon': context.user_data['gpon'],
        'tipo': context.user_data.get('tipo') or 'instalacao',
        'categoria': context.user_data.get('modo_registro') or 'instalacao',
        'fotos': context.user_data.get('fotos', []),
        'tecnico_id': update.message.from_user.id,
        'tecnico_nome': tecnico_nome,
        'tecnico_regiao': tecnico_regiao,
        'serial_modem': context.user_data.get('serial_modem'),
        'serial_mesh': context.user_data.get('serial_mesh'),
        'data': datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    }
    nova_instalacao = {k: v for k, v in nova_instalacao.items() if v is not None}
    
    ok = salvar_instalacao(nova_instalacao)
    
    def escape_markdown(text):
        if text is None:
            return 'nÃ£o informada'
        # Escapar caracteres especiais do Markdown v2
        special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
        for char in special_chars:
            text = str(text).replace(char, f'\\{char}')
        return text
    
    if ok:
        titulo = 'âœ… *REPARO REGISTRADO*' if nova_instalacao['categoria'] == 'reparo' else 'âœ… *INSTALAÃ‡ÃƒO REGISTRADA*'
        msg_parts = [
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n',
            f'{titulo}\n',
            'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n',
            'ğŸ“‹ *Detalhes:*\n',
            f'â€¢ SA: `{nova_instalacao["sa"]}`\n',
            f'â€¢ GPON: `{nova_instalacao["gpon"]}`\n'
        ]
    
        if nova_instalacao.get("serial_modem"):
            msg_parts.append(f'â€¢ Serial Modem: `{nova_instalacao["serial_modem"]}`\n')
            
        if nova_instalacao.get("serial_mesh"):
            msg_parts.append(f'â€¢ Serial Mesh: `{nova_instalacao["serial_mesh"]}`\n')
    
        msg_parts.extend([
            f'â€¢ Tipo: {escape_markdown(nova_instalacao["tipo"])}\n',
            f'â€¢ Categoria: {escape_markdown(nova_instalacao["categoria"])}\n',
            f'â€¢ Fotos: {len(nova_instalacao["fotos"])}\n\n',
            f'ğŸ‘¤ *TÃ©cnico:* {escape_markdown(nova_instalacao["tecnico_nome"])}\n',
            f'ğŸ“ *RegiÃ£o:* {escape_markdown(nova_instalacao["tecnico_regiao"])}\n',
            f'ğŸ“… *Data:* {escape_markdown(nova_instalacao["data"])}\n\n',
            'ğŸ‰ Ã“timo trabalho\\!\n\n',
            'Use /start para nova aÃ§Ã£o\\.'
        ])
        await update.message.reply_text(''.join(msg_parts), parse_mode='MarkdownV2')
    else:
        await update.message.reply_text('âŒ Falha ao salvar no Supabase. Verifique as variÃ¡veis de ambiente, permissÃµes (RLS) e o schema. Use /start para tentar novamente.', parse_mode='Markdown')
    
    context.user_data.clear()
    return ConversationHandler.END

# Consultar instalaÃ§Ã£o por SA ou GPON
async def consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto_busca = update.message.text.strip()
    dados = carregar_dados()

    termo = texto_busca.lower()
    resultados = []
    for d in dados:
        sa = str(d.get('sa') or '').lower()
        gpon = str(d.get('gpon') or '').lower()
        if termo in sa or termo in gpon:
            resultados.append(d)

    if not resultados:
        await update.message.reply_text(
            f'âŒ Nenhuma instalaÃ§Ã£o encontrada para: `{texto_busca}`',
            parse_mode='Markdown'
        )
        return ConversationHandler.END

    for resultado in resultados:
        # Escapar caracteres especiais para MarkdownV2
        def escape_md(text):
            if text is None:
                return 'N/A'
            special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
            text = str(text)
            for char in special_chars:
                text = text.replace(char, f'\\{char}')
            return text
        
        msg_parts = [
            f'ğŸ“‹ *SA:* `{resultado["sa"]}`\n',
            f'ğŸ”Œ *GPON:* `{resultado["gpon"]}`\n'
        ]
        
        # Adicionar serial se existir
        if resultado.get("serial_modem"):
            msg_parts.append(f'ğŸ“Ÿ *Serial:* `{resultado["serial_modem"]}`\n')
        
        msg_parts.extend([
            f'ğŸ§© *Tipo:* {escape_md(resultado.get("tipo", "instalacao"))}\n',
            f'ğŸ‘¤ *TÃ©cnico:* {escape_md(resultado["tecnico_nome"])}\n',
            f'ğŸ“… *Data:* {escape_md(resultado["data"])}\n',
            f'ğŸ“¸ *Fotos:* {len(resultado.get("fotos", []))}'
        ])
        
        msg = ''.join(msg_parts)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2')
        
        # Enviar as fotos
        for foto_id in resultado.get('fotos', []):
            try:
                await update.message.reply_photo(photo=foto_id)
            except:
                pass
    return ConversationHandler.END

async def comando_consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        'ğŸ” *Consultar InstalaÃ§Ã£o*\n\n'
        'Digite o nÃºmero da SA ou do GPON para buscar:',
        parse_mode='Markdown'
    )
    return AGUARDANDO_CONSULTA

async def comando_mensal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_mensal()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_semanal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_semanal()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_hoje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_hoje()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_reparo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['modo_registro'] = 'reparo'
    await update.message.reply_text(
        'ğŸ› ï¸ *Novo Reparo*\n\nEnvie o *nÃºmero da SA:*:\n'
        '_(Ou digite /cancelar para voltar)_',
        parse_mode='Markdown'
    )
    return AGUARDANDO_SA

async def receber_data_inicio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        inicio = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('âŒ Data invÃ¡lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_INICIO
    context.user_data['data_inicio'] = inicio
    modo = context.user_data.get('modo')
    if modo == 'producao':
        await update.message.reply_text(
            'Agora envie a *data de fechamento* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            'Agora envie a *data final* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
    return AGUARDANDO_DATA_FIM

async def iniciar_producao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    inicio_dt, fim_dt = ciclo_atual()
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'âŒ Nenhuma instalaÃ§Ã£o entre {inicio_dt.strftime("%d/%m/%Y")} e {fim_dt.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        return ConversationHandler.END
    msg = montar_msg_producao(instalacoes_user, inicio_dt, fim_dt, username)
    await update.message.reply_text(msg, parse_mode='Markdown')
    return ConversationHandler.END

async def receber_data_fim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        fim = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('âŒ Data invÃ¡lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio = context.user_data.get('data_inicio')
    if not inicio:
        await update.message.reply_text('âŒ Erro: envie a data inicial primeiro.', parse_mode='Markdown')
        return ConversationHandler.END
    if fim < inicio:
        await update.message.reply_text('âŒ A data final Ã© anterior Ã  inicial. Envie novamente a data final.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio_dt = inicio.replace(hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=TZ)
    fim_dt = fim.replace(hour=23, minute=59, second=59, microsecond=0).replace(tzinfo=TZ)
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'âŒ Nenhuma instalaÃ§Ã£o encontrada entre {inicio.strftime("%d/%m/%Y")} e {fim.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        context.user_data.pop('data_inicio', None)
        context.user_data.pop('modo', None)
        return ConversationHandler.END
    modo = context.user_data.get('modo')
    if modo == 'producao':
        dias_periodo = (fim_dt - inicio_dt).days + 1
        media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
        pontos = calcular_pontos(instalacoes_user)
        dias_produtivos = contar_dias_produtivos(instalacoes_user)
        turbo_ativo = dias_produtivos >= 24
        tier = obter_faixa_valor(pontos)
        valor_unit = tier['valor_turbo'] if turbo_ativo else tier['valor']
        valor_total = pontos * valor_unit
        msg = (
            f'ğŸ“† *ProduÃ§Ã£o no PerÃ­odo*\n'
            f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'ğŸ‘¤ TÃ©cnico: {username}\n\n'
            f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_user)}\n'
            f'ğŸ”¢ *Pontos:* {int(pontos)}\n'
            f'ğŸ·ï¸ *Faixa:* {tier["faixa"]}\n'
            f'ğŸ“… *Dias produtivos:* {dias_produtivos} (>=24 ativa Turbo)\n'
            f'âš¡ *Modo Turbo:* {"Ativo" if turbo_ativo else "Inativo"}\n'
            f'ğŸ’µ *Valor por ponto:* {_formata_brl(valor_unit)}\n'
            f'ğŸ’° *Valor total:* {_formata_brl(valor_total)}\n'
            f'ğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia\n'
        )
        await update.message.reply_text(msg, parse_mode='Markdown')
    else:
        msg = (
            f'ğŸ“† *RelatÃ³rio por PerÃ­odo*\n'
            f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'ğŸ‘¤ TÃ©cnico: {username}\n\n'
            f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_user)}\n\n'
        )
        ultimos = instalacoes_user[-10:]
        i = 1
        for inst in ultimos:
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
            i += 1
        await update.message.reply_text(msg, parse_mode='Markdown')
    context.user_data.pop('data_inicio', None)
    context.user_data.pop('modo', None)
    return ConversationHandler.END

# Cancelar operaÃ§Ã£o
async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('âŒ OperaÃ§Ã£o cancelada. Use /start para comeÃ§ar novamente.')
    context.user_data.clear()
    return ConversationHandler.END

# Configurar o bot
def main():
    def _clean_token(s: str):
        s = s.strip()
        for ch in ('`', '"', "'", '\r', '\n'):
            s = s.replace(ch, '')
        return s

    def _get_token():
        t = os.getenv("TELEGRAM_TOKEN")
        if t:
            return _clean_token(t)
        for p in ("/etc/secrets/TELEGRAM_TOKEN", "TELEGRAM_TOKEN"):
            try:
                if os.path.exists(p):
                    with open(p, "r", encoding="utf-8") as f:
                        c = _clean_token(f.read())
                        if c:
                            return c
            except:
                pass
        raise RuntimeError("TELEGRAM_TOKEN nÃ£o definido nas variÃ¡veis de ambiente ou secret file")
    
    async def post_init(application: Application) -> None:
        await application.bot.set_my_commands([
            BotCommand("start", "Menu principal"),
            BotCommand("ajuda", "Como usar o bot"),
            BotCommand("cancelar", "Cancelar operaÃ§Ã£o atual"),
            BotCommand("meuid", "ğŸ†” Descobrir meu ID"),
            BotCommand("admin", "ğŸ›ï¸ Painel de administraÃ§Ã£o"),
            BotCommand("mensal", "RelatÃ³rio mensal"),
            BotCommand("semanal", "RelatÃ³rio semanal"),
            BotCommand("hoje", "RelatÃ³rio de hoje"),
            BotCommand("consultar", "Consultar instalaÃ§Ã£o"),
            BotCommand("reparo", "Registrar reparo"),
            BotCommand("producao", "ProduÃ§Ã£o por perÃ­odo")
        ])
    
    TOKEN = _get_token()
    import re
    if not re.match(r"^\d+:[A-Za-z0-9_-]+$", TOKEN):
        raise RuntimeError("TELEGRAM_TOKEN invÃ¡lido. Verifique se copiou exatamente o token do @BotFather.")
    if not USE_SUPABASE:
        raise RuntimeError("SUPABASE_URL/SUPABASE_KEY nÃ£o definidos nas variÃ¡veis de ambiente")
    
    app = Application.builder().token(TOKEN).post_init(post_init).build()
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start), CommandHandler('producao', iniciar_producao), CommandHandler('consultar', comando_consultar), CommandHandler('reparo', comando_reparo), CallbackQueryHandler(button_callback)],
        states={
            AGUARDANDO_SA: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sa)],
            AGUARDANDO_GPON: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_gpon)],
            AGUARDANDO_TIPO: [CallbackQueryHandler(receber_tipo)],
            AGUARDANDO_SERIAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_serial)],
            AGUARDANDO_SERIAL_MESH: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_serial_mesh)],
            AGUARDANDO_FOTOS: [
                MessageHandler(filters.PHOTO, receber_foto),
                CommandHandler('finalizar', finalizar)
            ],
            AGUARDANDO_DATA_INICIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_inicio)],
            AGUARDANDO_DATA_FIM: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_fim)],
            AGUARDANDO_NOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_nome)],
            AGUARDANDO_SOBRENOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sobrenome)],
            AGUARDANDO_REGIAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_regiao)],
            AGUARDANDO_CONSULTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, consultar)],
            AGUARDANDO_BROADCAST: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, admin_send_broadcast),
                MessageHandler(filters.PHOTO, admin_send_broadcast),
                MessageHandler(filters.VIDEO, admin_send_broadcast),
                MessageHandler(filters.Document.ALL, admin_send_broadcast)
            ],
            AGUARDANDO_CONFIRMACAO_BROADCAST: [CallbackQueryHandler(confirmar_broadcast)],
        },
        fallbacks=[CommandHandler('cancelar', cancelar)]
    )
    
    app.add_handler(CommandHandler('admin', admin_panel))
    app.add_handler(CommandHandler('meuid', meu_id))
    app.add_handler(CommandHandler('mensal', comando_mensal))
    app.add_handler(CommandHandler('semanal', comando_semanal))
    app.add_handler(CommandHandler('hoje', comando_hoje))
    app.add_handler(CommandHandler('ajuda', ajuda))
    app.add_handler(conv_handler)
    
    # Iniciar servidor web falso para manter o bot vivo no Render
    keep_alive()
    
    # Verificar saÃºde do Supabase
    check_supabase_health()
    
    print('ğŸ¤– Bot iniciado (polling)! Aguardando mensagens...')
    app.run_polling()

if __name__ == '__main__':
    main()
