import os
import json
from datetime import datetime, timedelta
from collections import defaultdict
from zoneinfo import ZoneInfo
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, ContextTypes
from supabase import create_client, Client

# Estados da conversa
AGUARDANDO_SA, AGUARDANDO_GPON, AGUARDANDO_TIPO, AGUARDANDO_SERIAL, AGUARDANDO_FOTOS, AGUARDANDO_DATA_INICIO, AGUARDANDO_DATA_FIM, AGUARDANDO_NOME, AGUARDANDO_SOBRENOME, AGUARDANDO_REGIAO, AGUARDANDO_CONSULTA, AGUARDANDO_BROADCAST = range(12)

# Arquivo para salvar os dados
DADOS_FILE = 'instalacoes.json'
USUARIOS_FILE = 'usuarios.json'
TZ = ZoneInfo("America/Sao_Paulo")

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
USE_SUPABASE = bool(SUPABASE_URL and SUPABASE_KEY)
_SUPABASE_CLIENT = None

# Lista de IDs de administradores (adicione seu ID do Telegram aqui)
# Para descobrir seu ID, use o comando /meuid
ADMIN_IDS = [
    1797158471,  # Admin principal
]

PONTOS_SERVICO = {
    'defeito_banda_larga': 1.43,
    'defeito_linha': 1.43,
    'defeito_tv': 1.43,
    'instalacao': 2.28,
    'instalacao_tv': 3.58,
    'mudanca_endereco': 2.37,
    'retirada': 1.06,
    'servicos': 1.50,
    'servico': 1.50
}

TABELA_FAIXAS = [
    {'min': 164.0, 'max': float('inf'), 'faixa': 'A', 'valor': 3.20, 'valor_turbo': 8.00},
    {'min': 159.0, 'max': 163.99, 'faixa': 'B', 'valor': 2.40, 'valor_turbo': 6.00},
    {'min': 148.0, 'max': 158.99, 'faixa': 'C', 'valor': 1.60, 'valor_turbo': 4.00},
    {'min': 137.0, 'max': 147.99, 'faixa': 'D', 'valor': 1.00, 'valor_turbo': 2.50},
    {'min': 126.0, 'max': 136.99, 'faixa': 'E', 'valor': 0.80, 'valor_turbo': 2.25},
    {'min': 120.0, 'max': 125.99, 'faixa': 'F', 'valor': 0.70, 'valor_turbo': 2.00},
    {'min': 115.0, 'max': 119.99, 'faixa': 'G', 'valor': 0.70, 'valor_turbo': 1.75},
    {'min': 109.0, 'max': 114.99, 'faixa': 'H', 'valor': 0.60, 'valor_turbo': 1.50},
    {'min': 0.0,   'max': 108.99, 'faixa': 'I', 'valor': 0.00, 'valor_turbo': 0.00}
]

def _formata_brl(v: float) -> str:
    s = f"{v:,.2f}"
    s = s.replace(',', 'X').replace('.', ',').replace('X', '.')
    return f"R$ {s}"

def calcular_pontos(instalacoes: list) -> float:
    total = 0.0
    for inst in instalacoes:
        tipo = str(inst.get('tipo') or 'instalacao').lower()
        total += PONTOS_SERVICO.get(tipo, 1.0)
    return total

def contar_dias_produtivos(instalacoes: list) -> int:
    dias = set()
    for inst in instalacoes:
        try:
            dt = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M')
            dias.add(dt.date())
        except:
            continue
    return len(dias)

def obter_faixa_valor(pontos: float):
    p = float(pontos)
    for tier in TABELA_FAIXAS:
        if tier['min'] <= p <= tier['max']:
            return tier
    return TABELA_FAIXAS[-1]

def ciclo_atual():
    agora = datetime.now(TZ)
    if agora.day >= 16:
        inicio = datetime(agora.year, agora.month, 16, tzinfo=TZ)
        ano = agora.year + 1 if agora.month == 12 else agora.year
        mes = 1 if agora.month == 12 else agora.month + 1
        fim = datetime(ano, mes, 15, 23, 59, tzinfo=TZ)
    else:
        ano_prev = agora.year - 1 if agora.month == 1 else agora.year
        mes_prev = 12 if agora.month == 1 else agora.month - 1
        inicio = datetime(ano_prev, mes_prev, 16, tzinfo=TZ)
        fim = datetime(agora.year, agora.month, 15, 23, 59, tzinfo=TZ)
    return inicio, fim

def montar_msg_producao(instalacoes_user: list, inicio: datetime, fim: datetime, username: str):
    dias_periodo = (fim - inicio).days + 1
    media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
    pontos = calcular_pontos(instalacoes_user)
    dias_produtivos = contar_dias_produtivos(instalacoes_user)
    turbo_ativo = dias_produtivos >= 24
    tier = obter_faixa_valor(pontos)
    valor_unit = tier['valor_turbo'] if turbo_ativo else tier['valor']
    valor_total = pontos * valor_unit
    min_sem_turbo = _formata_brl(tier['min'] * tier['valor'])
    min_com_turbo = _formata_brl(tier['min'] * tier['valor_turbo'])
    msg = (
        f'ğŸ“† *ProduÃ§Ã£o no PerÃ­odo*\n'
        f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
        f'ğŸ‘¤ TÃ©cnico: {username}\n\n'
        f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_user)}\n'
        f'ğŸ”¢ *Pontos:* {int(pontos)}\n'
        f'ğŸ·ï¸ *Faixa:* {tier["faixa"]}\n'
        f'ğŸ“… *Dias produtivos:* {dias_produtivos} (>=24 ativa Turbo)\n'
        f'âš¡ *Modo Turbo:* {"Ativo" if turbo_ativo else "Inativo"}\n'
        f'ğŸ’µ *Valor por ponto:* {_formata_brl(valor_unit)}\n'
        f'ğŸ’° *Valor total:* {_formata_brl(valor_total)}\n'
        f'ğŸ”» *MÃ­nimo na faixa (s/ Turbo):* {min_sem_turbo}\n'
        f'ğŸ”º *MÃ­nimo na faixa (c/ Turbo):* {min_com_turbo}\n'
        f'ğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia\n'
    )
    return msg

def get_supabase():
    global _SUPABASE_CLIENT
    if not USE_SUPABASE:
        return None
    if _SUPABASE_CLIENT is None:
        _SUPABASE_CLIENT = create_client(SUPABASE_URL, SUPABASE_KEY)
    return _SUPABASE_CLIENT

# Carregar dados existentes
def carregar_dados():
    try:
        sb = get_supabase()
        resp = sb.table("instalacoes").select("*").execute()
        data = resp.data or []
        return data
    except:
        return []

# Salvar dados
def salvar_dados(dados):
    try:
        sb = get_supabase()
        if isinstance(dados, list):
            if dados:
                sb.table("instalacoes").insert(dados).execute()
        else:
            sb.table("instalacoes").insert(dados).execute()
    except:
        pass

def carregar_usuarios():
    try:
        sb = get_supabase()
        resp = sb.table("usuarios").select("*").execute()
        rows = resp.data or []
        usuarios = {}
        for r in rows:
            uid = str(r.get('id'))
            usuarios[uid] = {
                'nome': r.get('nome') or '',
                'sobrenome': r.get('sobrenome') or '',
                'regiao': r.get('regiao'),
                'telegram': r.get('telegram')
            }
        return usuarios
    except:
        return {}

def salvar_usuarios(usuarios):
    try:
        sb = get_supabase()
        payload = []
        for k, v in (usuarios or {}).items():
            payload.append({
                'id': int(k) if str(k).isdigit() else str(k),
                'nome': v.get('nome') or '',
                'sobrenome': v.get('sobrenome') or '',
                'regiao': v.get('regiao'),
                'telegram': v.get('telegram')
            })
        if payload:
            sb.table("usuarios").upsert(payload).execute()
    except:
        pass

def salvar_usuario(uid: str, dados_usuario: dict):
    try:
        sb = get_supabase()
        row = {
            'id': int(uid) if str(uid).isdigit() else str(uid),
            'nome': dados_usuario.get('nome') or '',
            'sobrenome': dados_usuario.get('sobrenome') or '',
            'regiao': dados_usuario.get('regiao'),
            'telegram': dados_usuario.get('telegram')
        }
        sb.table("usuarios").upsert(row).execute()
    except:
        pass

def salvar_instalacao(instalacao: dict):
    try:
        sb = get_supabase()
        sb.table("instalacoes").insert(instalacao).execute()
    except:
        pass

# Comando /ajuda
async def ajuda(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        'ğŸ†˜ *Central de Ajuda*\n\n'
        'Aqui estÃ£o os comandos disponÃ­veis:\n\n'
        'ğŸ”¹ /start - Iniciar o bot e ver o menu principal\n'
        'ğŸ”¹ /ajuda - Ver esta mensagem de ajuda\n'
        'ğŸ”¹ /cancelar - Cancelar a operaÃ§Ã£o atual\n'
        'ğŸ”¹ /meuid - Descobrir seu ID do Telegram\n'
        'ğŸ”¹ /mensal - RelatÃ³rio de produÃ§Ã£o mensal\n'
        'ğŸ”¹ /semanal - RelatÃ³rio de produÃ§Ã£o semanal\n'
        'ğŸ”¹ /hoje - RelatÃ³rio de produÃ§Ã£o de hoje\n'
        'ğŸ”¹ /consultar - Consultar uma instalaÃ§Ã£o por SA ou GPON\n'
        'ğŸ”¹ /reparo - Iniciar registro de reparo rÃ¡pido\n'
        'ğŸ”¹ /producao - Consultar produÃ§Ã£o por perÃ­odo\n\n'
        'ğŸ’¡ *Dica:* Se ficar preso em alguma etapa, digite /cancelar para voltar ao inÃ­cio.'
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /meuid - Descobre o ID do usuÃ¡rio
async def meu_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "NÃ£o definido"
    first_name = update.message.from_user.first_name
    
    msg = (
        f'ğŸ†” *Suas InformaÃ§Ãµes*\n\n'
        f'ğŸ‘¤ Nome: {first_name}\n'
        f'ğŸ”– Username: @{username}\n'
        f'ğŸ”¢ **ID do Telegram:** `{user_id}`\n\n'
        f'ğŸ’¡ *Para se tornar admin:*\n'
        f'Envie este ID para o administrador do sistema.\n'
        f'Ele deve adicionar `{user_id}` na lista `ADMIN_IDS`.'
    )
    
    await update.message.reply_text(msg, parse_mode='Markdown')

# ==================== PAINEL ADMIN ====================

def is_admin(user_id: int) -> bool:
    """Verifica se o usuÃ¡rio Ã© administrador"""
    return user_id in ADMIN_IDS

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Painel principal de administraÃ§Ã£o"""
    user_id = update.message.from_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text('âŒ Acesso negado. VocÃª nÃ£o tem permissÃ£o de administrador.')
        return
    
    keyboard = [
        [InlineKeyboardButton("ğŸ“Š EstatÃ­sticas Gerais", callback_data='admin_stats')],
        [InlineKeyboardButton("ğŸ‘¥ Listar TÃ©cnicos", callback_data='admin_users')],
        [InlineKeyboardButton("ğŸ“‹ Todas InstalaÃ§Ãµes", callback_data='admin_all_installs')],
        [InlineKeyboardButton("ï¿½ Enviar Mensagem para Todos", callback_data='admin_broadcast')],
        [InlineKeyboardButton("ï¿½ğŸ“¤ Exportar Dados", callback_data='admin_export')],
        [InlineKeyboardButton("ğŸ”§ Gerenciar Admins", callback_data='admin_manage')],
        [InlineKeyboardButton("ğŸ”™ Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        'ğŸ›ï¸ *Painel de AdministraÃ§Ã£o*\n\n'
        'Escolha uma opÃ§Ã£o:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def admin_stats(query):
    """Mostra estatÃ­sticas gerais do sistema"""
    dados = carregar_dados()
    usuarios = carregar_usuarios()
    
    # EstatÃ­sticas gerais
    total_instalacoes = len(dados)
    total_tecnicos = len(usuarios)
    
    # InstalaÃ§Ãµes por tipo
    por_tipo = defaultdict(int)
    por_categoria = defaultdict(int)
    for inst in dados:
        por_tipo[inst.get('tipo', 'instalacao')] += 1
        por_categoria[inst.get('categoria', 'instalacao')] += 1
    
    # InstalaÃ§Ãµes nos Ãºltimos 7 dias
    agora = datetime.now(TZ)
    sete_dias_atras = agora - timedelta(days=7)
    instalacoes_semana = 0
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst >= sete_dias_atras:
                instalacoes_semana += 1
        except:
            continue
    
    # Top 5 tÃ©cnicos
    por_tecnico = defaultdict(int)
    for inst in dados:
        por_tecnico[inst['tecnico_nome']] += 1
    top_tecnicos = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)[:5]
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = (
        f'ğŸ“Š *EstatÃ­sticas Gerais*\n\n'
        f'ğŸ‘¥ *TÃ©cnicos cadastrados:* {total_tecnicos}\n'
        f'ğŸ“¦ *Total de instalaÃ§Ãµes:* {total_instalacoes}\n'
        f'ğŸ“… *Ãšltimos 7 dias:* {instalacoes_semana}\n\n'
        f'ğŸ“‹ *Por Tipo:*\n'
    )
    
    for tipo, qtd in sorted(por_tipo.items(), key=lambda x: x[1], reverse=True):
        msg += f'  â€¢ {escape_md(tipo)}: {qtd}\n'
    
    msg += '\nğŸ† *Top 5 TÃ©cnicos:*\n'
    for idx, (tecnico, qtd) in enumerate(top_tecnicos, 1):
        msg += f'{idx}. {escape_md(tecnico)}: {qtd} instalaÃ§Ãµes\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_list_users(query):
    """Lista todos os tÃ©cnicos cadastrados"""
    usuarios = carregar_usuarios()
    dados = carregar_dados()
    
    # Contar instalaÃ§Ãµes por tÃ©cnico
    instalacoes_por_tecnico = defaultdict(int)
    for inst in dados:
        tecnico_id = str(inst.get('tecnico_id', ''))
        if tecnico_id:
            instalacoes_por_tecnico[tecnico_id] += 1
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = f'ğŸ‘¥ *TÃ©cnicos Cadastrados ({len(usuarios)})*\n\n'
    
    for user_id, dados_user in sorted(usuarios.items(), key=lambda x: instalacoes_por_tecnico.get(x[0], 0), reverse=True):
        nome_completo = f"{dados_user.get('nome', '')} {dados_user.get('sobrenome', '')}".strip()
        regiao = dados_user.get('regiao', 'N/A')
        qtd_instalacoes = instalacoes_por_tecnico.get(user_id, 0)
        is_adm = 'ğŸ‘‘' if int(user_id) in ADMIN_IDS else ''
        
        msg += f'{is_adm} *{escape_md(nome_completo)}*\n'
        msg += f'  ID: `{user_id}`\n'
        msg += f'  RegiÃ£o: {escape_md(regiao)}\n'
        msg += f'  InstalaÃ§Ãµes: {qtd_instalacoes}\n\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_all_installations(query):
    """Lista todas as instalaÃ§Ãµes recentes"""
    dados = carregar_dados()
    
    # Pegar as Ãºltimas 20 instalaÃ§Ãµes
    ultimas = dados[-20:] if len(dados) > 20 else dados
    ultimas.reverse()  # Mais recentes primeiro
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = f'ğŸ“‹ *Ãšltimas InstalaÃ§Ãµes ({len(ultimas)}/{len(dados)})*\n\n'
    
    for inst in ultimas:
        msg += f'ğŸ“… {escape_md(inst["data"])}\n'
        msg += f'SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
        msg += f'ğŸ‘¤ {escape_md(inst["tecnico_nome"])}\n'
        msg += f'ğŸ§© {escape_md(inst.get("tipo", "instalacao"))}\n\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_export_data(query):
    """Exporta dados em formato texto"""
    dados = carregar_dados()
    usuarios = carregar_usuarios()
    
    # Criar relatÃ³rio completo
    agora = datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    
    msg = f'ğŸ“¤ *ExportaÃ§Ã£o de Dados*\n'
    msg += f'Data: {agora}\n\n'
    msg += f'Total de instalaÃ§Ãµes: {len(dados)}\n'
    msg += f'Total de tÃ©cnicos: {len(usuarios)}\n\n'
    msg += 'ğŸ’¾ Para exportar dados completos, acesse o Supabase Dashboard:\n'
    msg += f'{SUPABASE_URL if SUPABASE_URL else "Configure SUPABASE_URL"}\n\n'
    msg += 'ğŸ“Š VocÃª tambÃ©m pode usar os comandos:\n'
    msg += '/mensal - RelatÃ³rio mensal\n'
    msg += '/semanal - RelatÃ³rio semanal\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_manage_admins(query):
    """Gerenciar administradores"""
    msg = (
        'ğŸ”§ *Gerenciar Administradores*\n\n'
        f'Admins atuais: {len(ADMIN_IDS)}\n\n'
        'ğŸ“ Para adicionar/remover admins:\n'
        '1. Edite o arquivo `tecnico_bot`\n'
        '2. Encontre a lista `ADMIN_IDS`\n'
        '3. Adicione ou remova IDs\n'
        '4. FaÃ§a deploy novamente\n\n'
        'ğŸ’¡ *Como descobrir um ID:*\n'
        'Use o comando /meuid ou\n'
        'PeÃ§a para o usuÃ¡rio enviar /start\n'
        'O ID aparecerÃ¡ nos logs do Render'
    )
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_broadcast_start(query):
    """Inicia o processo de broadcast"""
    msg = (
        'ğŸ“¢ *Enviar Mensagem para Todos*\n\n'
        'ğŸ“ Digite a mensagem que deseja enviar para todos os tÃ©cnicos cadastrados.\n\n'
        'ğŸ’¡ *Dicas:*\n'
        'â€¢ Use Markdown para formataÃ§Ã£o\n'
        'â€¢ Seja claro e objetivo\n'
        'â€¢ A mensagem serÃ¡ enviada para todos os usuÃ¡rios\n\n'
        'âš ï¸ Digite /cancelar para cancelar o envio.'
    )
    await query.edit_message_text(msg, parse_mode='Markdown')
    return AGUARDANDO_BROADCAST

async def admin_send_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia a mensagem broadcast para todos os tÃ©cnicos"""
    user_id = update.message.from_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text('âŒ Acesso negado.')
        return ConversationHandler.END
    
    mensagem = update.message.text.strip()
    usuarios = carregar_usuarios()
    
    if not usuarios:
        await update.message.reply_text('âŒ Nenhum tÃ©cnico cadastrado para enviar mensagem.')
        return ConversationHandler.END
    
    # Adicionar cabeÃ§alho Ã  mensagem
    mensagem_completa = (
        f'ğŸ“¢ *AVISO DA ADMINISTRAÃ‡ÃƒO*\n'
        f'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'
        f'{mensagem}\n\n'
        f'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”'
    )
    
    # Enviar para todos os usuÃ¡rios
    enviados = 0
    falhas = 0
    
    await update.message.reply_text('ğŸ“¤ Enviando mensagem para todos os tÃ©cnicos...')
    
    for uid in usuarios.keys():
        try:
            await context.bot.send_message(
                chat_id=int(uid),
                text=mensagem_completa,
                parse_mode='Markdown'
            )
            enviados += 1
        except Exception as e:
            falhas += 1
            print(f"Erro ao enviar para {uid}: {e}")
    
    # RelatÃ³rio de envio
    relatorio = (
        f'âœ… *Broadcast ConcluÃ­do!*\n\n'
        f'ğŸ“Š *EstatÃ­sticas:*\n'
        f'âœ… Enviados: {enviados}\n'
        f'âŒ Falhas: {falhas}\n'
        f'ğŸ‘¥ Total de tÃ©cnicos: {len(usuarios)}\n\n'
        f'ğŸ’¡ Falhas podem ocorrer se o usuÃ¡rio bloqueou o bot.'
    )
    
    await update.message.reply_text(relatorio, parse_mode='Markdown')
    return ConversationHandler.END

async def admin_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para callbacks do painel admin"""
    query = update.callback_query
    user_id = query.from_user.id
    
    if not is_admin(user_id):
        await query.answer('âŒ Acesso negado', show_alert=True)
        return
    
    await query.answer()
    
    if query.data == 'admin_stats':
        await admin_stats(query)
    elif query.data == 'admin_users':
        await admin_list_users(query)
    elif query.data == 'admin_all_installs':
        await admin_all_installations(query)
    elif query.data == 'admin_broadcast':
        return await admin_broadcast_start(query)
    elif query.data == 'admin_export':
        await admin_export_data(query)
    elif query.data == 'admin_manage':
        await admin_manage_admins(query)

# ==================== FIM PAINEL ADMIN ====================

# Comando /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    print(f"ğŸ” User ID: {user_id} | Username: {username}")  # Log para descobrir IDs
    
    usuarios = carregar_usuarios()
    if str(user_id) not in usuarios:
        context.user_data['ident'] = {}
        await update.message.reply_text('ğŸ‘¤ Primeiro acesso. Informe seu nome:\n_(Ou /cancelar para sair)_')
        return AGUARDANDO_NOME
    keyboard = [
        [InlineKeyboardButton("ğŸ†• Registrar InstalaÃ§Ã£o", callback_data='registrar')],
        [InlineKeyboardButton("ğŸ› ï¸ Registrar Reparo", callback_data='registrar_reparo')],
        [InlineKeyboardButton("ğŸ” Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("ğŸ“‚ Minhas InstalaÃ§Ãµes", callback_data='minhas')],
        [InlineKeyboardButton("ğŸ“… Consulta ProduÃ§Ã£o", callback_data='consulta_producao')],
        [InlineKeyboardButton("ğŸ“Š RelatÃ³rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'ğŸ› ï¸ *Bot de Registro de InstalaÃ§Ãµes*\n\n'
        'Bem-vindo! Escolha uma opÃ§Ã£o:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    return ConversationHandler.END

async def receber_nome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['nome'] = update.message.text.strip()
    await update.message.reply_text('Informe seu sobrenome:\n_(Ou /cancelar para sair)_')
    return AGUARDANDO_SOBRENOME

async def receber_sobrenome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['sobrenome'] = update.message.text.strip()
    await update.message.reply_text('Informe sua regiÃ£o de atuaÃ§Ã£o:\n_(Ou /cancelar para sair)_')
    return AGUARDANDO_REGIAO

async def receber_regiao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    regiao = update.message.text.strip()
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
    ident = context.user_data.get('ident', {})
    dados_usuario = {
        'nome': ident.get('nome', ''),
        'sobrenome': ident.get('sobrenome', ''),
        'regiao': regiao,
        'telegram': update.message.from_user.username or update.message.from_user.first_name
    }
    usuarios[str(user_id)] = dados_usuario
    salvar_usuario(str(user_id), dados_usuario)
    keyboard = [
        [InlineKeyboardButton("ğŸ†• Registrar InstalaÃ§Ã£o", callback_data='registrar')],
        [InlineKeyboardButton("ğŸ› ï¸ Registrar Reparo", callback_data='registrar_reparo')],
        [InlineKeyboardButton("ğŸ” Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("ğŸ“‚ Minhas InstalaÃ§Ãµes", callback_data='minhas')],
        [InlineKeyboardButton("ğŸ“… Consulta ProduÃ§Ã£o", callback_data='consulta_producao')],
        [InlineKeyboardButton("ğŸ“Š RelatÃ³rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'âœ… Perfil salvo!\n\nAgora vocÃª pode usar o menu:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    context.user_data.pop('ident', None)
    return ConversationHandler.END

# Menu de relatÃ³rios
async def menu_relatorios(query):
    keyboard = [
        [InlineKeyboardButton("ğŸ“… RelatÃ³rio Mensal", callback_data='rel_mensal')],
        [InlineKeyboardButton("ğŸ“Š RelatÃ³rio Semanal", callback_data='rel_semanal')],
        [InlineKeyboardButton("ğŸ“† RelatÃ³rio por PerÃ­odo", callback_data='rel_periodo')],
        [InlineKeyboardButton("ğŸ“ˆ RelatÃ³rio Hoje", callback_data='rel_hoje')],
        [InlineKeyboardButton("ğŸ† Ranking TÃ©cnicos", callback_data='rel_ranking')],
        [InlineKeyboardButton("ğŸ”™ Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        'ğŸ“Š *RelatÃ³rios DisponÃ­veis*\n\n'
        'Escolha o tipo de relatÃ³rio:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Gerar relatÃ³rio mensal
def gerar_relatorio_mensal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    mes_atual = agora.month
    ano_atual = agora.year
    
    # Filtrar instalaÃ§Ãµes do mÃªs atual
    instalacoes_mes = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.month == mes_atual and data_inst.year == ano_atual:
                instalacoes_mes.append(inst)
        except:
            continue
    
    if not instalacoes_mes:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada neste mÃªs."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_mes:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    nome_mes = agora.strftime('%B/%Y')
    msg = f'ğŸ“… *RelatÃ³rio Mensal - {nome_mes}*\n\n'
    msg += f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_mes)}\n\n'
    msg += 'ğŸ‘¥ *Por TÃ©cnico:*\n'
    
    # Ordenar por quantidade (maior para menor)
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    # MÃ©dia diÃ¡ria
    dias_mes = agora.day
    media_dia = len(instalacoes_mes) / dias_mes
    msg += f'\nğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia'
    
    return msg

# Gerar relatÃ³rio semanal
def gerar_relatorio_semanal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    inicio_semana = agora - timedelta(days=agora.weekday())
    inicio_semana = inicio_semana.replace(hour=0, minute=0, second=0, microsecond=0)
    
    # Filtrar instalaÃ§Ãµes da semana
    instalacoes_semana = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst >= inicio_semana:
                instalacoes_semana.append(inst)
        except:
            continue
    
    if not instalacoes_semana:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada nesta semana."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_semana:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = f'ğŸ“Š *RelatÃ³rio Semanal*\n'
    msg += f'PerÃ­odo: {inicio_semana.strftime("%d/%m")} atÃ© {agora.strftime("%d/%m/%Y")}\n\n'
    msg += f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_semana)}\n\n'
    msg += 'ğŸ‘¥ *Por TÃ©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    # MÃ©dia diÃ¡ria da semana
    dias_semana = (agora - inicio_semana).days + 1
    media_dia = len(instalacoes_semana) / dias_semana
    msg += f'\nğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia'
    
    return msg

# Gerar relatÃ³rio do dia
def gerar_relatorio_hoje():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    
    # Filtrar instalaÃ§Ãµes de hoje
    instalacoes_hoje = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.date() == agora.date():
                instalacoes_hoje.append(inst)
        except:
            continue
    
    if not instalacoes_hoje:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada hoje."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_hoje:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = f'ğŸ“ˆ *RelatÃ³rio de Hoje - {agora.strftime("%d/%m/%Y")}*\n\n'
    msg += f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_hoje)}\n\n'
    msg += 'ğŸ‘¥ *Por TÃ©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    return msg

# Gerar ranking geral
def gerar_ranking_tecnicos():
    dados = carregar_dados()
    
    if not dados:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada ainda."
    
    # Contar por tÃ©cnico (todos os tempos)
    por_tecnico = defaultdict(int)
    for inst in dados:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = f'ğŸ† *Ranking Geral de TÃ©cnicos*\n\n'
    msg += f'ğŸ“Š *Total Geral:* {len(dados)} instalaÃ§Ãµes\n\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    
    medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰']
    for idx, (tecnico, quantidade) in enumerate(tecnicos_ordenados, 1):
        medal = medals[idx-1] if idx <= 3 else f'{idx}Âº'
        percentual = (quantidade / len(dados)) * 100
        msg += f'{medal} *{tecnico}*\n'
        msg += f'   {quantidade} instalaÃ§Ãµes ({percentual:.1f}%)\n\n'
    
    return msg

# Callback dos botÃµes
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'registrar':
        context.user_data['modo_registro'] = 'instalacao'
        await query.edit_message_text(
            'ğŸ†• *Nova InstalaÃ§Ã£o*\n\n'
            'Por favor, envie o *nÃºmero da SA*:\n'
            '_(Ou digite /cancelar para voltar)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'registrar_reparo':
        context.user_data['modo_registro'] = 'reparo'
        await query.edit_message_text(
            'ğŸ› ï¸ *Novo Reparo*\n\n'
            'Por favor, envie o *nÃºmero da SA:*:\n'
            '_(Ou digite /cancelar para voltar)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'consultar':
        await query.edit_message_text(
            'ğŸ” *Consultar InstalaÃ§Ã£o*\n\n'
            'Digite o nÃºmero da SA ou do GPON para buscar:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_CONSULTA

    elif query.data == 'consulta_producao':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        inicio_dt, fim_dt = ciclo_atual()
        instalacoes_user = []
        for d in dados:
            try:
                data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
                if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                    instalacoes_user.append(d)
            except:
                continue
        if not instalacoes_user:
            msg = f'âŒ Nenhuma instalaÃ§Ã£o entre {inicio_dt.strftime("%d/%m/%Y")} e {fim_dt.strftime("%d/%m/%Y")}.'
            await query.edit_message_text(msg, parse_mode='Markdown')
            return None
        msg = montar_msg_producao(instalacoes_user, inicio_dt, fim_dt, username)
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'minhas':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        
        instalacoes_user = [d for d in dados if d.get('tecnico_id') == user_id]
        
        if not instalacoes_user:
            await query.edit_message_text('VocÃª ainda nÃ£o registrou nenhuma instalaÃ§Ã£o.')
            return None
        
        msg = f'ğŸ“‚ *Suas InstalaÃ§Ãµes ({len(instalacoes_user)})*\n\n'
        for i, inst in enumerate(instalacoes_user[-10:], 1):  # Ãšltimas 10
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
        
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'relatorios':
        await menu_relatorios(query)
        return None
    
    elif query.data == 'rel_mensal':
        msg = gerar_relatorio_mensal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_semanal':
        msg = gerar_relatorio_semanal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_hoje':
        msg = gerar_relatorio_hoje()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_periodo':
        await query.edit_message_text(
            'ğŸ“† *RelatÃ³rio por PerÃ­odo*\n\nEnvie a *data inicial* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para voltar)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_DATA_INICIO
    
    elif query.data == 'rel_ranking':
        msg = gerar_ranking_tecnicos()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    # Callbacks do painel admin
    elif query.data.startswith('admin_'):
        await admin_callback_handler(update, context)
        return None
    
    elif query.data == 'voltar':
        keyboard = [
            [InlineKeyboardButton("ğŸ†• Registrar InstalaÃ§Ã£o", callback_data='registrar')],
            [InlineKeyboardButton("ğŸ› ï¸ Registrar Reparo", callback_data='registrar_reparo')],
            [InlineKeyboardButton("ğŸ” Consultar SA/GPON", callback_data='consultar')],
            [InlineKeyboardButton("ğŸ“‚ Minhas InstalaÃ§Ãµes", callback_data='minhas')],
            [InlineKeyboardButton("ğŸ“… Consulta ProduÃ§Ã£o", callback_data='consulta_producao')],
            [InlineKeyboardButton("ğŸ“Š RelatÃ³rios", callback_data='relatorios')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            'ğŸ› ï¸ *Bot de Registro de InstalaÃ§Ãµes*\n\n'
            'Bem-vindo! Escolha uma opÃ§Ã£o:',
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        return None

# Receber nÃºmero da SA
async def receber_sa(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sa = update.message.text.strip()
    # ValidaÃ§Ã£o removida a pedido do usuÃ¡rio
    context.user_data['sa'] = sa
    await update.message.reply_text(
        'âœ… SA registrada!\n\n'
        'Agora envie o *GPON*:\n'
        '_(Ou digite /cancelar para sair)_',
        parse_mode='Markdown'
    )
    return AGUARDANDO_GPON

# Receber GPON
async def receber_gpon(update: Update, context: ContextTypes.DEFAULT_TYPE):
    gpon = update.message.text.strip()
    # ValidaÃ§Ã£o removida a pedido do usuÃ¡rio
    context.user_data['gpon'] = gpon
    context.user_data['fotos'] = []
    modo = context.user_data.get('modo_registro') or 'instalacao'
    if modo == 'reparo':
        keyboard = [
            [InlineKeyboardButton('Defeito Banda Larga', callback_data='defeito_banda_larga')],
            [InlineKeyboardButton('Defeito Linha', callback_data='defeito_linha')],
            [InlineKeyboardButton('Defeito TV', callback_data='defeito_tv')],
            [InlineKeyboardButton('MudanÃ§a de EndereÃ§o', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('Retirada', callback_data='retirada')],
            [InlineKeyboardButton('ServiÃ§os', callback_data='servicos')]
        ]
        prompt = 'âœ… GPON registrado!\n\nSelecione o *tipo de reparo*:'
    else:
        keyboard = [
            [InlineKeyboardButton('InstalaÃ§Ã£o', callback_data='instalacao')],
            [InlineKeyboardButton('InstalaÃ§Ã£o TV', callback_data='instalacao_tv')],
            [InlineKeyboardButton('MudanÃ§a de EndereÃ§o', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('ServiÃ§os', callback_data='servicos')]
        ]
        prompt = 'âœ… GPON registrado!\n\nSelecione o *tipo de serviÃ§o*:'
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(prompt, reply_markup=reply_markup, parse_mode='Markdown')
    return AGUARDANDO_TIPO

# Receber fotos
async def receber_foto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'fotos' not in context.user_data:
        context.user_data['fotos'] = []
    
    # Pega a foto de maior resoluÃ§Ã£o
    photo = update.message.photo[-1]
    file_id = photo.file_id
    context.user_data['fotos'].append(file_id)
    
    num_fotos = len(context.user_data['fotos'])
    
    if num_fotos < 3:
        await update.message.reply_text(
            f'âœ… Foto {num_fotos}/3 recebida!\n'
            f'Envie mais {3 - num_fotos} foto(s) ou /finalizar se jÃ¡ enviou todas.'
        )
    else:
        await update.message.reply_text(
            f'âœ… {num_fotos} fotos recebidas!\n'
            'Digite /finalizar para salvar a instalaÃ§Ã£o.'
        )
    
    return AGUARDANDO_FOTOS

async def receber_tipo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tipo = query.data
    context.user_data['tipo'] = tipo
    print(f"DEBUG receber_tipo: Tipo selecionado = {tipo}")
    
    # Verificar se precisa do Serial do Modem
    tipos_com_serial = ['instalacao', 'instalacao_tv', 'mudanca_endereco']
    
    if tipo in tipos_com_serial:
        print(f"DEBUG receber_tipo: Tipo {tipo} requer serial, indo para AGUARDANDO_SERIAL")
        await query.edit_message_text(
            'âœ… Tipo selecionado!\n\n'
            'ğŸ“Ÿ Agora envie o *NÃºmero de SÃ©rie do Modem*:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SERIAL
    else:
        print(f"DEBUG receber_tipo: Tipo {tipo} nÃ£o requer serial, indo para AGUARDANDO_FOTOS")
        await query.edit_message_text(
            'âœ… Tipo selecionado!\n\n'
            'ğŸ“¸ Agora envie as *3 fotos* da instalaÃ§Ã£o.\n'
            'Quando terminar, digite /finalizar',
            parse_mode='Markdown'
        )
        return AGUARDANDO_FOTOS

async def receber_serial(update: Update, context: ContextTypes.DEFAULT_TYPE):
    serial = update.message.text.strip()
    context.user_data['serial_modem'] = serial
    print(f"DEBUG: Serial recebido: {serial}")
    print(f"DEBUG: Context user_data: {context.user_data}")
    
    await update.message.reply_text(
        'âœ… Serial registrado!\n\n'
        'ğŸ“¸ Agora envie as *3 fotos* da instalaÃ§Ã£o.\n'
        'Quando terminar, digite /finalizar',
        parse_mode='Markdown'
    )
    print("DEBUG: Mensagem enviada, retornando AGUARDANDO_FOTOS")
    return AGUARDANDO_FOTOS

# Finalizar registro
async def finalizar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'sa' not in context.user_data or 'gpon' not in context.user_data:
        await update.message.reply_text('âŒ Erro: Dados incompletos. Use /start para comeÃ§ar novamente.')
        return ConversationHandler.END
    
    usuarios = carregar_usuarios()
    uid = str(update.message.from_user.id)
    perfil = usuarios.get(uid)
    tecnico_nome = (f"{perfil.get('nome','')} {perfil.get('sobrenome','')}".strip() if perfil else (update.message.from_user.username or update.message.from_user.first_name))
    tecnico_regiao = (perfil.get('regiao') if perfil else None)
    
    nova_instalacao = {
        'sa': context.user_data['sa'],
        'gpon': context.user_data['gpon'],
        'tipo': context.user_data.get('tipo') or 'instalacao',
        'categoria': context.user_data.get('modo_registro') or 'instalacao',
        'fotos': context.user_data.get('fotos', []),
        'tecnico_id': update.message.from_user.id,
        'tecnico_nome': tecnico_nome,
        'tecnico_regiao': tecnico_regiao,
        'serial_modem': context.user_data.get('serial_modem'),
        'data': datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    }
    
    salvar_instalacao(nova_instalacao)
    
    # Escapar caracteres especiais do Markdown
    def escape_markdown(text):
        if text is None:
            return 'nÃ£o informada'
        # Escapar caracteres especiais do Markdown v2
        special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
        for char in special_chars:
            text = str(text).replace(char, f'\\{char}')
        return text
    
    msg_parts = [
        'âœ… *InstalaÃ§Ã£o registrada com sucesso\\!*\n\n',
        f'ğŸ“‹ SA: `{nova_instalacao["sa"]}`\n',
        f'ğŸ”Œ GPON: `{nova_instalacao["gpon"]}`\n'
    ]
    
    if nova_instalacao.get("serial_modem"):
        msg_parts.append(f'ğŸ“Ÿ Serial: `{nova_instalacao["serial_modem"]}`\n')
    
    msg_parts.extend([
        f'ğŸ§© Tipo: {escape_markdown(nova_instalacao["tipo"])}\n',
        f'ğŸ—‚ï¸ Categoria: {escape_markdown(nova_instalacao["categoria"])}\n',
        f'ğŸ“¸ Fotos: {len(nova_instalacao["fotos"])}\n',
        f'ğŸ‘¤ TÃ©cnico: {escape_markdown(nova_instalacao["tecnico_nome"])}\n',
        f'ğŸ“ RegiÃ£o: {escape_markdown(nova_instalacao["tecnico_regiao"])}\n',
        f'ğŸ“… Data: {escape_markdown(nova_instalacao["data"])}\n\n',
        'Use /start para nova aÃ§Ã£o\\.'
    ])
    
    await update.message.reply_text(
        ''.join(msg_parts),
        parse_mode='MarkdownV2'
    )
    
    context.user_data.clear()
    return ConversationHandler.END

# Consultar instalaÃ§Ã£o por SA ou GPON
async def consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto_busca = update.message.text.strip()
    dados = carregar_dados()

    termo = texto_busca.lower()
    resultados = []
    for d in dados:
        sa = str(d.get('sa') or '').lower()
        gpon = str(d.get('gpon') or '').lower()
        if termo in sa or termo in gpon:
            resultados.append(d)

    if not resultados:
        await update.message.reply_text(
            f'âŒ Nenhuma instalaÃ§Ã£o encontrada para: `{texto_busca}`',
            parse_mode='Markdown'
        )
        return ConversationHandler.END

    for resultado in resultados:
        # Escapar caracteres especiais para MarkdownV2
        def escape_md(text):
            if text is None:
                return 'N/A'
            special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
            text = str(text)
            for char in special_chars:
                text = text.replace(char, f'\\{char}')
            return text
        
        msg_parts = [
            f'ğŸ“‹ *SA:* `{resultado["sa"]}`\n',
            f'ğŸ”Œ *GPON:* `{resultado["gpon"]}`\n'
        ]
        
        # Adicionar serial se existir
        if resultado.get("serial_modem"):
            msg_parts.append(f'ğŸ“Ÿ *Serial:* `{resultado["serial_modem"]}`\n')
        
        msg_parts.extend([
            f'ğŸ§© *Tipo:* {escape_md(resultado.get("tipo", "instalacao"))}\n',
            f'ğŸ‘¤ *TÃ©cnico:* {escape_md(resultado["tecnico_nome"])}\n',
            f'ğŸ“… *Data:* {escape_md(resultado["data"])}\n',
            f'ğŸ“¸ *Fotos:* {len(resultado.get("fotos", []))}'
        ])
        
        msg = ''.join(msg_parts)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2')
        
        # Enviar as fotos
        for foto_id in resultado.get('fotos', []):
            try:
                await update.message.reply_photo(photo=foto_id)
            except:
                pass
    return ConversationHandler.END

async def comando_consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        'ğŸ” *Consultar InstalaÃ§Ã£o*\n\n'
        'Digite o nÃºmero da SA ou do GPON para buscar:',
        parse_mode='Markdown'
    )
    return AGUARDANDO_CONSULTA

async def comando_mensal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_mensal()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_semanal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_semanal()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_hoje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_hoje()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_reparo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['modo_registro'] = 'reparo'
    await update.message.reply_text(
        'ğŸ› ï¸ *Novo Reparo*\n\nEnvie o *nÃºmero da SA:*:\n'
        '_(Ou digite /cancelar para voltar)_',
        parse_mode='Markdown'
    )
    return AGUARDANDO_SA

async def receber_data_inicio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        inicio = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('âŒ Data invÃ¡lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_INICIO
    context.user_data['data_inicio'] = inicio
    modo = context.user_data.get('modo')
    if modo == 'producao':
        await update.message.reply_text(
            'Agora envie a *data de fechamento* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            'Agora envie a *data final* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
    return AGUARDANDO_DATA_FIM

async def iniciar_producao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    inicio_dt, fim_dt = ciclo_atual()
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'âŒ Nenhuma instalaÃ§Ã£o entre {inicio_dt.strftime("%d/%m/%Y")} e {fim_dt.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        return ConversationHandler.END
    msg = montar_msg_producao(instalacoes_user, inicio_dt, fim_dt, username)
    await update.message.reply_text(msg, parse_mode='Markdown')
    return ConversationHandler.END

async def receber_data_fim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        fim = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('âŒ Data invÃ¡lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio = context.user_data.get('data_inicio')
    if not inicio:
        await update.message.reply_text('âŒ Erro: envie a data inicial primeiro.', parse_mode='Markdown')
        return ConversationHandler.END
    if fim < inicio:
        await update.message.reply_text('âŒ A data final Ã© anterior Ã  inicial. Envie novamente a data final.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio_dt = inicio.replace(hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=TZ)
    fim_dt = fim.replace(hour=23, minute=59, second=59, microsecond=0).replace(tzinfo=TZ)
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'âŒ Nenhuma instalaÃ§Ã£o encontrada entre {inicio.strftime("%d/%m/%Y")} e {fim.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        context.user_data.pop('data_inicio', None)
        context.user_data.pop('modo', None)
        return ConversationHandler.END
    modo = context.user_data.get('modo')
    if modo == 'producao':
        dias_periodo = (fim_dt - inicio_dt).days + 1
        media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
        pontos = calcular_pontos(instalacoes_user)
        dias_produtivos = contar_dias_produtivos(instalacoes_user)
        turbo_ativo = dias_produtivos >= 24
        tier = obter_faixa_valor(pontos)
        valor_unit = tier['valor_turbo'] if turbo_ativo else tier['valor']
        valor_total = pontos * valor_unit
        msg = (
            f'ğŸ“† *ProduÃ§Ã£o no PerÃ­odo*\n'
            f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'ğŸ‘¤ TÃ©cnico: {username}\n\n'
            f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_user)}\n'
            f'ğŸ”¢ *Pontos:* {int(pontos)}\n'
            f'ğŸ·ï¸ *Faixa:* {tier["faixa"]}\n'
            f'ğŸ“… *Dias produtivos:* {dias_produtivos} (>=24 ativa Turbo)\n'
            f'âš¡ *Modo Turbo:* {"Ativo" if turbo_ativo else "Inativo"}\n'
            f'ğŸ’µ *Valor por ponto:* {_formata_brl(valor_unit)}\n'
            f'ğŸ’° *Valor total:* {_formata_brl(valor_total)}\n'
            f'ğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia\n'
        )
        await update.message.reply_text(msg, parse_mode='Markdown')
    else:
        msg = (
            f'ğŸ“† *RelatÃ³rio por PerÃ­odo*\n'
            f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'ğŸ‘¤ TÃ©cnico: {username}\n\n'
            f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_user)}\n\n'
        )
        ultimos = instalacoes_user[-10:]
        i = 1
        for inst in ultimos:
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
            i += 1
        await update.message.reply_text(msg, parse_mode='Markdown')
    context.user_data.pop('data_inicio', None)
    context.user_data.pop('modo', None)
    return ConversationHandler.END

# Cancelar operaÃ§Ã£o
async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('âŒ OperaÃ§Ã£o cancelada. Use /start para comeÃ§ar novamente.')
    context.user_data.clear()
    return ConversationHandler.END

# Configurar o bot
def main():
    def _clean_token(s: str):
        s = s.strip()
        for ch in ('`', '"', "'", '\r', '\n'):
            s = s.replace(ch, '')
        return s

    def _get_token():
        t = os.getenv("TELEGRAM_TOKEN")
        if t:
            return _clean_token(t)
        for p in ("/etc/secrets/TELEGRAM_TOKEN", "TELEGRAM_TOKEN"):
            try:
                if os.path.exists(p):
                    with open(p, "r", encoding="utf-8") as f:
                        c = _clean_token(f.read())
                        if c:
                            return c
            except:
                pass
        raise RuntimeError("TELEGRAM_TOKEN nÃ£o definido nas variÃ¡veis de ambiente ou secret file")
    
    async def post_init(application: Application) -> None:
        await application.bot.set_my_commands([
            BotCommand("start", "Menu principal"),
            BotCommand("ajuda", "Como usar o bot"),
            BotCommand("cancelar", "Cancelar operaÃ§Ã£o atual"),
            BotCommand("meuid", "ğŸ†” Descobrir meu ID"),
            BotCommand("admin", "ğŸ›ï¸ Painel de administraÃ§Ã£o"),
            BotCommand("mensal", "RelatÃ³rio mensal"),
            BotCommand("semanal", "RelatÃ³rio semanal"),
            BotCommand("hoje", "RelatÃ³rio de hoje"),
            BotCommand("consultar", "Consultar instalaÃ§Ã£o"),
            BotCommand("reparo", "Registrar reparo"),
            BotCommand("producao", "ProduÃ§Ã£o por perÃ­odo")
        ])
    
    TOKEN = _get_token()
    import re
    if not re.match(r"^\d+:[A-Za-z0-9_-]+$", TOKEN):
        raise RuntimeError("TELEGRAM_TOKEN invÃ¡lido. Verifique se copiou exatamente o token do @BotFather.")
    if not USE_SUPABASE:
        raise RuntimeError("SUPABASE_URL/SUPABASE_KEY nÃ£o definidos nas variÃ¡veis de ambiente")
    
    app = Application.builder().token(TOKEN).post_init(post_init).build()
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start), CommandHandler('producao', iniciar_producao), CommandHandler('consultar', comando_consultar), CommandHandler('reparo', comando_reparo), CallbackQueryHandler(button_callback)],
        states={
            AGUARDANDO_SA: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sa)],
            AGUARDANDO_GPON: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_gpon)],
            AGUARDANDO_TIPO: [CallbackQueryHandler(receber_tipo)],
            AGUARDANDO_SERIAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_serial)],
            AGUARDANDO_FOTOS: [
                MessageHandler(filters.PHOTO, receber_foto),
                CommandHandler('finalizar', finalizar)
            ],
            AGUARDANDO_DATA_INICIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_inicio)],
            AGUARDANDO_DATA_FIM: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_fim)],
            AGUARDANDO_NOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_nome)],
            AGUARDANDO_SOBRENOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sobrenome)],
            AGUARDANDO_REGIAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_regiao)],
            AGUARDANDO_CONSULTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, consultar)],
            AGUARDANDO_BROADCAST: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_send_broadcast)],
        },
        fallbacks=[CommandHandler('cancelar', cancelar)]
    )
    
    app.add_handler(CommandHandler('admin', admin_panel))
    app.add_handler(CommandHandler('meuid', meu_id))
    app.add_handler(CommandHandler('mensal', comando_mensal))
    app.add_handler(CommandHandler('semanal', comando_semanal))
    app.add_handler(CommandHandler('hoje', comando_hoje))
    app.add_handler(CommandHandler('ajuda', ajuda))
    app.add_handler(conv_handler)
    
    base_url = os.getenv("WEBHOOK_BASE_URL") or os.getenv("RENDER_EXTERNAL_URL")
    if base_url:
        port = int(os.getenv("PORT", "10000"))
        url_path = TOKEN
        webhook_url = f"{base_url}/{url_path}"
        print('ğŸ¤– Bot iniciado (webhook)! Aguardando mensagens...')
        app.run_webhook(listen="0.0.0.0", port=port, url_path=url_path, webhook_url=webhook_url)
    else:
        print('ğŸ¤– Bot iniciado (polling)! Aguardando mensagens...')
        app.run_polling()

if __name__ == '__main__':
    main()
