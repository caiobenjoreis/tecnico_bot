import os
import json
from datetime import datetime, timedelta
from collections import defaultdict
from zoneinfo import ZoneInfo
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, ContextTypes
from supabase import create_client, Client

# Estados da conversa
# Estados da conversa
AGUARDANDO_SA, AGUARDANDO_GPON, AGUARDANDO_TIPO, AGUARDANDO_SERIAL, AGUARDANDO_FOTOS, AGUARDANDO_DATA_INICIO, AGUARDANDO_DATA_FIM, AGUARDANDO_NOME, AGUARDANDO_SOBRENOME, AGUARDANDO_REGIAO, AGUARDANDO_CONSULTA = range(11)

# Arquivo para salvar os dados
DADOS_FILE = 'instalacoes.json'
USUARIOS_FILE = 'usuarios.json'
TZ = ZoneInfo("America/Sao_Paulo")

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
USE_SUPABASE = bool(SUPABASE_URL and SUPABASE_KEY)
_SUPABASE_CLIENT = None

PONTOS_SERVICO = {
    'defeito_banda_larga': 1.43,
    'defeito_linha': 1.43,
    'defeito_tv': 1.43,
    'instalacao': 2.28,
    'instalacao_tv': 3.58,
    'mudanca_endereco': 2.37,
    'retirada': 1.06,
    'servicos': 1.50,
    'servico': 1.50
}

TABELA_FAIXAS = [
    {'min': 164.0, 'max': float('inf'), 'faixa': 'A', 'valor': 3.20, 'valor_turbo': 8.00},
    {'min': 159.0, 'max': 163.99, 'faixa': 'B', 'valor': 2.40, 'valor_turbo': 6.00},
    {'min': 148.0, 'max': 158.99, 'faixa': 'C', 'valor': 1.60, 'valor_turbo': 4.00},
    {'min': 137.0, 'max': 147.99, 'faixa': 'D', 'valor': 1.00, 'valor_turbo': 2.50},
    {'min': 126.0, 'max': 136.99, 'faixa': 'E', 'valor': 0.80, 'valor_turbo': 2.25},
    {'min': 120.0, 'max': 125.99, 'faixa': 'F', 'valor': 0.70, 'valor_turbo': 2.00},
    {'min': 115.0, 'max': 119.99, 'faixa': 'G', 'valor': 0.70, 'valor_turbo': 1.75},
    {'min': 109.0, 'max': 114.99, 'faixa': 'H', 'valor': 0.60, 'valor_turbo': 1.50},
    {'min': 0.0,   'max': 108.99, 'faixa': 'I', 'valor': 0.00, 'valor_turbo': 0.00}
]

def _formata_brl(v: float) -> str:
    s = f"{v:,.2f}"
    s = s.replace(',', 'X').replace('.', ',').replace('X', '.')
    return f"R$ {s}"

def calcular_pontos(instalacoes: list) -> float:
    total = 0.0
    for inst in instalacoes:
        tipo = str(inst.get('tipo') or 'instalacao').lower()
        total += PONTOS_SERVICO.get(tipo, 1.0)
    return total

def contar_dias_produtivos(instalacoes: list) -> int:
    dias = set()
    for inst in instalacoes:
        try:
            dt = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M')
            dias.add(dt.date())
        except:
            continue
    return len(dias)

def obter_faixa_valor(pontos: float):
    p = float(pontos)
    for tier in TABELA_FAIXAS:
        if tier['min'] <= p <= tier['max']:
            return tier
    return TABELA_FAIXAS[-1]

def ciclo_atual():
    agora = datetime.now(TZ)
    if agora.day >= 16:
        inicio = datetime(agora.year, agora.month, 16, tzinfo=TZ)
        ano = agora.year + 1 if agora.month == 12 else agora.year
        mes = 1 if agora.month == 12 else agora.month + 1
        fim = datetime(ano, mes, 15, 23, 59, tzinfo=TZ)
    else:
        ano_prev = agora.year - 1 if agora.month == 1 else agora.year
        mes_prev = 12 if agora.month == 1 else agora.month - 1
        inicio = datetime(ano_prev, mes_prev, 16, tzinfo=TZ)
        fim = datetime(agora.year, agora.month, 15, 23, 59, tzinfo=TZ)
    return inicio, fim

def montar_msg_producao(instalacoes_user: list, inicio: datetime, fim: datetime, username: str):
    dias_periodo = (fim - inicio).days + 1
    media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
    pontos = calcular_pontos(instalacoes_user)
    dias_produtivos = contar_dias_produtivos(instalacoes_user)
    turbo_ativo = dias_produtivos >= 24
    tier = obter_faixa_valor(pontos)
    valor_unit = tier['valor_turbo'] if turbo_ativo else tier['valor']
    valor_total = pontos * valor_unit
    min_sem_turbo = _formata_brl(tier['min'] * tier['valor'])
    min_com_turbo = _formata_brl(tier['min'] * tier['valor_turbo'])
    msg = (
        f'ðŸ“† *ProduÃ§Ã£o no PerÃ­odo*\n'
        f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
        f'ðŸ‘¤ TÃ©cnico: {username}\n\n'
        f'ðŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_user)}\n'
        f'ðŸ”¢ *Pontos:* {int(pontos)}\n'
        f'ðŸ·ï¸ *Faixa:* {tier["faixa"]}\n'
        f'ðŸ“… *Dias produtivos:* {dias_produtivos} (>=24 ativa Turbo)\n'
        f'âš¡ *Modo Turbo:* {"Ativo" if turbo_ativo else "Inativo"}\n'
        f'ðŸ’µ *Valor por ponto:* {_formata_brl(valor_unit)}\n'
        f'ðŸ’° *Valor total:* {_formata_brl(valor_total)}\n'
        f'ðŸ”» *MÃ­nimo na faixa (s/ Turbo):* {min_sem_turbo}\n'
        f'ðŸ”º *MÃ­nimo na faixa (c/ Turbo):* {min_com_turbo}\n'
        f'ðŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia\n'
    )
    return msg

def get_supabase():
    global _SUPABASE_CLIENT
    if not USE_SUPABASE:
        return None
    if _SUPABASE_CLIENT is None:
        _SUPABASE_CLIENT = create_client(SUPABASE_URL, SUPABASE_KEY)
    return _SUPABASE_CLIENT

# Carregar dados existentes
def carregar_dados():
    try:
        sb = get_supabase()
        resp = sb.table("instalacoes").select("*").execute()
        data = resp.data or []
        return data
    except:
        return []

# Salvar dados
def salvar_dados(dados):
    try:
        sb = get_supabase()
        if isinstance(dados, list):
            if dados:
                sb.table("instalacoes").insert(dados).execute()
        else:
            sb.table("instalacoes").insert(dados).execute()
    except:
        pass

def carregar_usuarios():
    try:
        sb = get_supabase()
        resp = sb.table("usuarios").select("*").execute()
        rows = resp.data or []
        usuarios = {}
        for r in rows:
            uid = str(r.get('id'))
            usuarios[uid] = {
                'nome': r.get('nome') or '',
                'sobrenome': r.get('sobrenome') or '',
                'regiao': r.get('regiao'),
                'telegram': r.get('telegram')
            }
        return usuarios
    except:
        return {}

def salvar_usuarios(usuarios):
    try:
        sb = get_supabase()
        payload = []
        for k, v in (usuarios or {}).items():
            payload.append({
                'id': int(k) if str(k).isdigit() else str(k),
                'nome': v.get('nome') or '',
                'sobrenome': v.get('sobrenome') or '',
                'regiao': v.get('regiao'),
                'telegram': v.get('telegram')
            })
        if payload:
            sb.table("usuarios").upsert(payload).execute()
    except:
        pass

def salvar_usuario(uid: str, dados_usuario: dict):
    try:
        sb = get_supabase()
        row = {
            'id': int(uid) if str(uid).isdigit() else str(uid),
            'nome': dados_usuario.get('nome') or '',
            'sobrenome': dados_usuario.get('sobrenome') or '',
            'regiao': dados_usuario.get('regiao'),
            'telegram': dados_usuario.get('telegram')
        }
        sb.table("usuarios").upsert(row).execute()
    except:
        pass

def salvar_instalacao(instalacao: dict):
    try:
        sb = get_supabase()
        sb.table("instalacoes").insert(instalacao).execute()
    except:
        pass

# Comando /ajuda
async def ajuda(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        'ðŸ†˜ *Central de Ajuda*\n\n'
        'Aqui estÃ£o os comandos disponÃ­veis:\n\n'
        'ðŸ”¹ /start - Iniciar o bot e ver o menu principal\n'
        'ðŸ”¹ /ajuda - Ver esta mensagem de ajuda\n'
        'ðŸ”¹ /cancelar - Cancelar a operaÃ§Ã£o atual\n'
        'ðŸ”¹ /mensal - RelatÃ³rio de produÃ§Ã£o mensal\n'
        'ðŸ”¹ /semanal - RelatÃ³rio de produÃ§Ã£o semanal\n'
        'ðŸ”¹ /hoje - RelatÃ³rio de produÃ§Ã£o de hoje\n'
        'ðŸ”¹ /consultar - Consultar uma instalaÃ§Ã£o por SA ou GPON\n'
        'ðŸ”¹ /reparo - Iniciar registro de reparo rÃ¡pido\n'
        'ðŸ”¹ /producao - Consultar produÃ§Ã£o por perÃ­odo\n\n'
        'ðŸ’¡ *Dica:* Se ficar preso em alguma etapa, digite /cancelar para voltar ao inÃ­cio.'
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        return None

# Receber nÃºmero da SA
async def receber_sa(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sa = update.message.text.strip()
    # ValidaÃ§Ã£o removida a pedido do usuÃ¡rio
    context.user_data['sa'] = sa
    await update.message.reply_text(
        'âœ… SA registrada!\n\n'
        'Agora envie o *GPON*:\n'
        '_(Ou digite /cancelar para sair)_',
        parse_mode='Markdown'
    )
    return AGUARDANDO_GPON

# Receber GPON
async def receber_gpon(update: Update, context: ContextTypes.DEFAULT_TYPE):
    gpon = update.message.text.strip()
    # ValidaÃ§Ã£o removida a pedido do usuÃ¡rio
    context.user_data['gpon'] = gpon
    context.user_data['fotos'] = []
    modo = context.user_data.get('modo_registro') or 'instalacao'
    if modo == 'reparo':
        keyboard = [
            [InlineKeyboardButton('Defeito Banda Larga', callback_data='defeito_banda_larga')],
            [InlineKeyboardButton('Defeito Linha', callback_data='defeito_linha')],
            [InlineKeyboardButton('Defeito TV', callback_data='defeito_tv')],
            [InlineKeyboardButton('MudanÃ§a de EndereÃ§o', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('Retirada', callback_data='retirada')],
            [InlineKeyboardButton('ServiÃ§os', callback_data='servicos')]
        ]
        prompt = 'âœ… GPON registrado!\n\nSelecione o *tipo de reparo*:'
    else:
        keyboard = [
            [InlineKeyboardButton('InstalaÃ§Ã£o', callback_data='instalacao')],
            [InlineKeyboardButton('InstalaÃ§Ã£o TV', callback_data='instalacao_tv')],
            [InlineKeyboardButton('MudanÃ§a de EndereÃ§o', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('ServiÃ§os', callback_data='servicos')]
        ]
        prompt = 'âœ… GPON registrado!\n\nSelecione o *tipo de serviÃ§o*:'
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(prompt, reply_markup=reply_markup, parse_mode='Markdown')
    return AGUARDANDO_TIPO

# Receber fotos
async def receber_foto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'fotos' not in context.user_data:
        context.user_data['fotos'] = []
    
    # Pega a foto de maior resoluÃ§Ã£o
    photo = update.message.photo[-1]
    file_id = photo.file_id
    context.user_data['fotos'].append(file_id)
    
    num_fotos = len(context.user_data['fotos'])
    
    if num_fotos < 3:
        await update.message.reply_text(
            f'âœ… Foto {num_fotos}/3 recebida!\n'
            f'Envie mais {3 - num_fotos} foto(s) ou /finalizar se jÃ¡ enviou todas.'
        )
    else:
        await update.message.reply_text(
            f'âœ… {num_fotos} fotos recebidas!\n'
            'Digite /finalizar para salvar a instalaÃ§Ã£o.'
        )
    
    return AGUARDANDO_FOTOS

async def receber_tipo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tipo = query.data
    context.user_data['tipo'] = tipo
    
    # Verificar se precisa do Serial do Modem
    tipos_com_serial = ['instalacao', 'instalacao_tv', 'mudanca_endereco']
    
    if tipo in tipos_com_serial:
        await query.edit_message_text(
            'âœ… Tipo selecionado!\n\n'
            'ðŸ“Ÿ Agora envie o *NÃºmero de SÃ©rie do Modem*:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SERIAL
    else:
        await query.edit_message_text(
            'âœ… Tipo selecionado!\n\n'
            'ðŸ“¸ Agora envie as *3 fotos* da instalaÃ§Ã£o.\n'
            'Quando terminar, digite /finalizar',
            parse_mode='Markdown'
        )
        return AGUARDANDO_FOTOS

async def receber_serial(update: Update, context: ContextTypes.DEFAULT_TYPE):
    serial = update.message.text.strip()
    context.user_data['serial_modem'] = serial
    
    await update.message.reply_text(
        'âœ… Serial registrado!\n\n'
        'ðŸ“¸ Agora envie as *3 fotos* da instalaÃ§Ã£o.\n'
        'Quando terminar, digite /finalizar',
        parse_mode='Markdown'
    )
    return AGUARDANDO_FOTOS

# Finalizar registro
async def finalizar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'sa' not in context.user_data or 'gpon' not in context.user_data:
        await update.message.reply_text('âŒ Erro: Dados incompletos. Use /start para comeÃ§ar novamente.')
        return ConversationHandler.END
    
    usuarios = carregar_usuarios()
    uid = str(update.message.from_user.id)
    perfil = usuarios.get(uid)
    tecnico_nome = (f"{perfil.get('nome','')} {perfil.get('sobrenome','')}".strip() if perfil else (update.message.from_user.username or update.message.from_user.first_name))
    tecnico_regiao = (perfil.get('regiao') if perfil else None)
    
    nova_instalacao = {
        'sa': context.user_data['sa'],
        'gpon': context.user_data['gpon'],
        'tipo': context.user_data.get('tipo') or 'instalacao',
        'categoria': context.user_data.get('modo_registro') or 'instalacao',
        'fotos': context.user_data.get('fotos', []),
        'tecnico_id': update.message.from_user.id,
        'tecnico_nome': tecnico_nome,
        'tecnico_regiao': tecnico_regiao,
        'serial_modem': context.user_data.get('serial_modem'),
        'data': datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    }
    
    salvar_instalacao(nova_instalacao)
    
    msg_serial = f'ðŸ“Ÿ Serial: `{nova_instalacao["serial_modem"]}`\n' if nova_instalacao.get("serial_modem") else ''
    
    await update.message.reply_text(
        'âœ… *InstalaÃ§Ã£o registrada com sucesso!*\n\n'
        f'ðŸ“‹ SA: `{nova_instalacao["sa"]}`\n'
        f'ðŸ”Œ GPON: `{nova_instalacao["gpon"]}`\n'
        f'{msg_serial}'
        f'ðŸ§© Tipo: {nova_instalacao["tipo"]}\n'
        f'ðŸ—‚ï¸ Categoria: {nova_instalacao["categoria"]}\n'
        f'ðŸ“¸ Fotos: {len(nova_instalacao["fotos"])}\n'
        f'ðŸ‘¤ TÃ©cnico: {nova_instalacao["tecnico_nome"]}\n'
        f'ðŸ“ RegiÃ£o: {nova_instalacao["tecnico_regiao"] or "nÃ£o informada"}\n'
        f'ðŸ“… Data: {nova_instalacao["data"]}\n\n'
        'Use /start para nova aÃ§Ã£o.',
        parse_mode='Markdown'
    )
    
    context.user_data.clear()
    return ConversationHandler.END

# Consultar instalaÃ§Ã£o por SA ou GPON
async def consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto_busca = update.message.text.strip()
    dados = carregar_dados()

    termo = texto_busca.lower()
    resultados = []
    for d in dados:
        sa = str(d.get('sa') or '').lower()
        gpon = str(d.get('gpon') or '').lower()
        if termo in sa or termo in gpon:
            resultados.append(d)

    if not resultados:
        await update.message.reply_text(
            f'âŒ Nenhuma instalaÃ§Ã£o encontrada para: `{texto_busca}`',
            parse_mode='Markdown'
        )
        return ConversationHandler.END

    for resultado in resultados:
        msg = (
            f'ðŸ“‹ *SA:* `{resultado["sa"]}`\n'
            f'ðŸ”Œ *GPON:* `{resultado["gpon"]}`\n'
            f'ðŸ§© *Tipo:* {resultado.get("tipo", "instalacao")}\n'
            f'ðŸ‘¤ *TÃ©cnico:* {resultado["tecnico_nome"]}`\n'
            f'ðŸ“… *Data:* {resultado["data"]}`\n'
            f'ðŸ“¸ *Fotos:* {len(resultado.get("fotos", []))}'
        )
        
        await update.message.reply_text(msg, parse_mode='Markdown')
        
        # Enviar as fotos
        for foto_id in resultado.get('fotos', []):
            try:
                await update.message.reply_photo(photo=foto_id)
            i += 1
        await update.message.reply_text(msg, parse_mode='Markdown')
    context.user_data.pop('data_inicio', None)
    context.user_data.pop('modo', None)
    return ConversationHandler.END

# Cancelar operaÃ§Ã£o
async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('âŒ OperaÃ§Ã£o cancelada. Use /start para comeÃ§ar novamente.')
    context.user_data.clear()
    return ConversationHandler.END

# Configurar o bot
def main():
    def _clean_token(s: str):
        s = s.strip()
        for ch in ('`', '"', "'", '\r', '\n'):
            s = s.replace(ch, '')
        return s

    def _get_token():
        t = os.getenv("TELEGRAM_TOKEN")
        if t:
            return _clean_token(t)
        for p in ("/etc/secrets/TELEGRAM_TOKEN", "TELEGRAM_TOKEN"):
            try:
                if os.path.exists(p):
                    with open(p, "r", encoding="utf-8") as f:
                        c = _clean_token(f.read())
                        if c:
                            return c
            except:
                pass
        raise RuntimeError("TELEGRAM_TOKEN nÃ£o definido nas variÃ¡veis de ambiente ou secret file")
    TOKEN = _get_token()
    import re
    if not re.match(r"^\d+:[A-Za-z0-9_-]+$", TOKEN):
        raise RuntimeError("TELEGRAM_TOKEN invÃ¡lido. Verifique se copiou exatamente o token do @BotFather.")
    if not USE_SUPABASE:
        raise RuntimeError("SUPABASE_URL/SUPABASE_KEY nÃ£o definidos nas variÃ¡veis de ambiente")
    
    app = Application.builder().token(TOKEN).build()
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start), CommandHandler('producao', iniciar_producao), CommandHandler('consultar', comando_consultar), CommandHandler('reparo', comando_reparo), CallbackQueryHandler(button_callback)],
        states={
            AGUARDANDO_SA: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sa)],
            AGUARDANDO_GPON: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_gpon)],
            AGUARDANDO_TIPO: [CallbackQueryHandler(receber_tipo)],
            AGUARDANDO_SERIAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_serial)],
            AGUARDANDO_FOTOS: [
                MessageHandler(filters.PHOTO, receber_foto),
                CommandHandler('finalizar', finalizar)
            ],
            AGUARDANDO_DATA_INICIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_inicio)],
            AGUARDANDO_DATA_FIM: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_fim)],
            AGUARDANDO_NOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_nome)],
            AGUARDANDO_SOBRENOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sobrenome)],
            AGUARDANDO_REGIAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_regiao)],
            AGUARDANDO_CONSULTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, consultar)],
        },
        fallbacks=[CommandHandler('cancelar', cancelar)]
    )
    
    app.add_handler(CommandHandler('mensal', comando_mensal))
    app.add_handler(CommandHandler('semanal', comando_semanal))
    app.add_handler(CommandHandler('hoje', comando_hoje))
    app.add_handler(CommandHandler('ajuda', ajuda))
    app.add_handler(conv_handler)
    
    base_url = os.getenv("WEBHOOK_BASE_URL") or os.getenv("RENDER_EXTERNAL_URL")
    if base_url:
        port = int(os.getenv("PORT", "10000"))
        url_path = TOKEN
        webhook_url = f"{base_url}/{url_path}"
        print('ðŸ¤– Bot iniciado (webhook)! Aguardando mensagens...')
        await app.bot.set_my_commands([
            BotCommand("start", "Menu principal"),
            BotCommand("ajuda", "Como usar o bot"),
            BotCommand("cancelar", "Cancelar operaÃ§Ã£o atual"),
            BotCommand("mensal", "RelatÃ³rio mensal"),
            BotCommand("semanal", "RelatÃ³rio semanal"),
            BotCommand("hoje", "RelatÃ³rio de hoje"),
            BotCommand("consultar", "Consultar instalaÃ§Ã£o"),
            BotCommand("reparo", "Registrar reparo"),
            BotCommand("producao", "ProduÃ§Ã£o por perÃ­odo")
        ])
        app.run_webhook(listen="0.0.0.0", port=port, url_path=url_path, webhook_url=webhook_url)
    else:
        print('ðŸ¤– Bot iniciado (polling)! Aguardando mensagens...')
        await app.bot.set_my_commands([
            BotCommand("start", "Menu principal"),
            BotCommand("ajuda", "Como usar o bot"),
            BotCommand("cancelar", "Cancelar operaÃ§Ã£o atual"),
            BotCommand("mensal", "RelatÃ³rio mensal"),
            BotCommand("semanal", "RelatÃ³rio semanal"),
            BotCommand("hoje", "RelatÃ³rio de hoje"),
            BotCommand("consultar", "Consultar instalaÃ§Ã£o"),
            BotCommand("reparo", "Registrar reparo"),
            BotCommand("producao", "ProduÃ§Ã£o por perÃ­odo")
        ])
        app.run_polling()

if __name__ == '__main__':
    main()
