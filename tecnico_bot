import os
import json
from datetime import datetime, timedelta
from collections import defaultdict
from zoneinfo import ZoneInfo
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, ContextTypes

# Estados da conversa
AGUARDANDO_SA, AGUARDANDO_GPON, AGUARDANDO_FOTOS, AGUARDANDO_DATA_INICIO, AGUARDANDO_DATA_FIM, AGUARDANDO_NOME, AGUARDANDO_SOBRENOME, AGUARDANDO_REGIAO = range(8)

# Arquivo para salvar os dados
DADOS_FILE = 'instalacoes.json'
USUARIOS_FILE = 'usuarios.json'
TZ = ZoneInfo("America/Sao_Paulo")

# Carregar dados existentes
def carregar_dados():
    if os.path.exists(DADOS_FILE):
        try:
            with open(DADOS_FILE, 'r', encoding='utf-8') as f:
                c = f.read().strip()
                if not c:
                    return []
                return json.loads(c)
        except:
            return []
    return []

# Salvar dados
def salvar_dados(dados):
    with open(DADOS_FILE, 'w', encoding='utf-8') as f:
        json.dump(dados, f, ensure_ascii=False, indent=2)

def carregar_usuarios():
    if os.path.exists(USUARIOS_FILE):
        try:
            with open(USUARIOS_FILE, 'r', encoding='utf-8') as f:
                c = f.read().strip()
                if not c:
                    return {}
                return json.loads(c)
        except:
            return {}
    return {}

def salvar_usuarios(usuarios):
    with open(USUARIOS_FILE, 'w', encoding='utf-8') as f:
        json.dump(usuarios, f, ensure_ascii=False, indent=2)

# Comando /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
    if str(user_id) not in usuarios:
        context.user_data['ident'] = {}
        await update.message.reply_text('ğŸ‘¤ Primeiro acesso. Informe seu nome:')
        return AGUARDANDO_NOME
    keyboard = [
        [InlineKeyboardButton("ğŸ“ Registrar InstalaÃ§Ã£o", callback_data='registrar')],
        [InlineKeyboardButton("ğŸ” Consultar GPON", callback_data='consultar')],
        [InlineKeyboardButton("ğŸ“Š Minhas InstalaÃ§Ãµes", callback_data='minhas')],
        [InlineKeyboardButton("ğŸ“ˆ RelatÃ³rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'ğŸ› ï¸ *Bot de Registro de InstalaÃ§Ãµes*\n\n'
        'Bem-vindo! Escolha uma opÃ§Ã£o:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    return ConversationHandler.END

async def receber_nome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['nome'] = update.message.text.strip()
    await update.message.reply_text('Informe seu sobrenome:')
    return AGUARDANDO_SOBRENOME

async def receber_sobrenome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['sobrenome'] = update.message.text.strip()
    await update.message.reply_text('Informe sua regiÃ£o de atuaÃ§Ã£o:')
    return AGUARDANDO_REGIAO

async def receber_regiao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    regiao = update.message.text.strip()
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
    ident = context.user_data.get('ident', {})
    usuarios[str(user_id)] = {
        'nome': ident.get('nome', ''),
        'sobrenome': ident.get('sobrenome', ''),
        'regiao': regiao,
        'telegram': update.message.from_user.username or update.message.from_user.first_name
    }
    salvar_usuarios(usuarios)
    keyboard = [
        [InlineKeyboardButton("ğŸ“ Registrar InstalaÃ§Ã£o", callback_data='registrar')],
        [InlineKeyboardButton("ğŸ” Consultar SA", callback_data='consultar')],
        [InlineKeyboardButton("ğŸ“Š Minhas InstalaÃ§Ãµes", callback_data='minhas')],
        [InlineKeyboardButton("ğŸ“ˆ RelatÃ³rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'âœ… Perfil salvo!\n\nAgora vocÃª pode usar o menu:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    context.user_data.pop('ident', None)
    return ConversationHandler.END

# Menu de relatÃ³rios
async def menu_relatorios(query):
    keyboard = [
        [InlineKeyboardButton("ğŸ“… RelatÃ³rio Mensal", callback_data='rel_mensal')],
        [InlineKeyboardButton("ğŸ“Š RelatÃ³rio Semanal", callback_data='rel_semanal')],
        [InlineKeyboardButton("ğŸ“† RelatÃ³rio por PerÃ­odo", callback_data='rel_periodo')],
        [InlineKeyboardButton("ğŸ“ˆ RelatÃ³rio Hoje", callback_data='rel_hoje')],
        [InlineKeyboardButton("ğŸ† Ranking TÃ©cnicos", callback_data='rel_ranking')],
        [InlineKeyboardButton("ğŸ”™ Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        'ğŸ“ˆ *RelatÃ³rios DisponÃ­veis*\n\n'
        'Escolha o tipo de relatÃ³rio:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Gerar relatÃ³rio mensal
def gerar_relatorio_mensal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    mes_atual = agora.month
    ano_atual = agora.year
    
    # Filtrar instalaÃ§Ãµes do mÃªs atual
    instalacoes_mes = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.month == mes_atual and data_inst.year == ano_atual:
                instalacoes_mes.append(inst)
        except:
            continue
    
    if not instalacoes_mes:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada neste mÃªs."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_mes:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    nome_mes = agora.strftime('%B/%Y')
    msg = f'ğŸ“… *RelatÃ³rio Mensal - {nome_mes}*\n\n'
    msg += f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_mes)}\n\n'
    msg += 'ğŸ‘¥ *Por TÃ©cnico:*\n'
    
    # Ordenar por quantidade (maior para menor)
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    # MÃ©dia diÃ¡ria
    dias_mes = agora.day
    media_dia = len(instalacoes_mes) / dias_mes
    msg += f'\nğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia'
    
    return msg

# Gerar relatÃ³rio semanal
def gerar_relatorio_semanal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    inicio_semana = agora - timedelta(days=agora.weekday())
    inicio_semana = inicio_semana.replace(hour=0, minute=0, second=0, microsecond=0)
    
    # Filtrar instalaÃ§Ãµes da semana
    instalacoes_semana = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst >= inicio_semana:
                instalacoes_semana.append(inst)
        except:
            continue
    
    if not instalacoes_semana:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada nesta semana."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_semana:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = f'ğŸ“Š *RelatÃ³rio Semanal*\n'
    msg += f'PerÃ­odo: {inicio_semana.strftime("%d/%m")} atÃ© {agora.strftime("%d/%m/%Y")}\n\n'
    msg += f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_semana)}\n\n'
    msg += 'ğŸ‘¥ *Por TÃ©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    # MÃ©dia diÃ¡ria da semana
    dias_semana = (agora - inicio_semana).days + 1
    media_dia = len(instalacoes_semana) / dias_semana
    msg += f'\nğŸ“ˆ *MÃ©dia diÃ¡ria:* {media_dia:.1f} instalaÃ§Ãµes/dia'
    
    return msg

# Gerar relatÃ³rio do dia
def gerar_relatorio_hoje():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    
    # Filtrar instalaÃ§Ãµes de hoje
    instalacoes_hoje = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.date() == agora.date():
                instalacoes_hoje.append(inst)
        except:
            continue
    
    if not instalacoes_hoje:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada hoje."
    
    # Contar por tÃ©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_hoje:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = f'ğŸ“ˆ *RelatÃ³rio de Hoje - {agora.strftime("%d/%m/%Y")}*\n\n'
    msg += f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_hoje)}\n\n'
    msg += 'ğŸ‘¥ *Por TÃ©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  â€¢ {tecnico}: *{quantidade}* instalaÃ§Ãµes\n'
    
    return msg

# Gerar ranking geral
def gerar_ranking_tecnicos():
    dados = carregar_dados()
    
    if not dados:
        return "âŒ Nenhuma instalaÃ§Ã£o registrada ainda."
    
    # Contar por tÃ©cnico (todos os tempos)
    por_tecnico = defaultdict(int)
    for inst in dados:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relatÃ³rio
    msg = f'ğŸ† *Ranking Geral de TÃ©cnicos*\n\n'
    msg += f'ğŸ“Š *Total Geral:* {len(dados)} instalaÃ§Ãµes\n\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    
    medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰']
    for idx, (tecnico, quantidade) in enumerate(tecnicos_ordenados, 1):
        medal = medals[idx-1] if idx <= 3 else f'{idx}Âº'
        percentual = (quantidade / len(dados)) * 100
        msg += f'{medal} *{tecnico}*\n'
        msg += f'   {quantidade} instalaÃ§Ãµes ({percentual:.1f}%)\n\n'
    
    return msg

# Callback dos botÃµes
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'registrar':
        await query.edit_message_text(
            'ğŸ“ *Nova InstalaÃ§Ã£o*\n\n'
            'Por favor, envie o *nÃºmero da SA*:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'consultar':
        await query.edit_message_text(
            'ğŸ” *Consultar InstalaÃ§Ã£o*\n\n'
            'Digite o nÃºmero do GPON para buscar:',
            parse_mode='Markdown'
        )
        return None
    
    elif query.data == 'minhas':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        
        instalacoes_user = [d for d in dados if d.get('tecnico_id') == user_id]
        
        if not instalacoes_user:
            await query.edit_message_text('VocÃª ainda nÃ£o registrou nenhuma instalaÃ§Ã£o.')
            return None
        
        msg = f'ğŸ“Š *Suas InstalaÃ§Ãµes ({len(instalacoes_user)})*\n\n'
        for i, inst in enumerate(instalacoes_user[-10:], 1):  # Ãšltimas 10
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
        
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'relatorios':
        await menu_relatorios(query)
        return None
    
    elif query.data == 'rel_mensal':
        msg = gerar_relatorio_mensal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_semanal':
        msg = gerar_relatorio_semanal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_hoje':
        msg = gerar_relatorio_hoje()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_periodo':
        await query.edit_message_text(
            'ğŸ“† *RelatÃ³rio por PerÃ­odo*\n\nEnvie a *data inicial* no formato `dd/mm/aaaa`:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_DATA_INICIO
    
    elif query.data == 'rel_ranking':
        msg = gerar_ranking_tecnicos()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'voltar':
        keyboard = [
            [InlineKeyboardButton("ğŸ“ Registrar InstalaÃ§Ã£o", callback_data='registrar')],
            [InlineKeyboardButton("ğŸ” Consultar GPON", callback_data='consultar')],
            [InlineKeyboardButton("ğŸ“Š Minhas InstalaÃ§Ãµes", callback_data='minhas')],
            [InlineKeyboardButton("ğŸ“ˆ RelatÃ³rios", callback_data='relatorios')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            'ğŸ› ï¸ *Bot de Registro de InstalaÃ§Ãµes*\n\n'
            'Bem-vindo! Escolha uma opÃ§Ã£o:',
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        return None

# Receber nÃºmero da SA
async def receber_sa(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['sa'] = update.message.text.strip()
    await update.message.reply_text(
        'âœ… SA registrada!\n\n'
        'Agora envie o *GPON*:',
        parse_mode='Markdown'
    )
    return AGUARDANDO_GPON

# Receber GPON
async def receber_gpon(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['gpon'] = update.message.text.strip()
    context.user_data['fotos'] = []
    
    await update.message.reply_text(
        'âœ… GPON registrado!\n\n'
        'ğŸ“¸ Agora envie as *3 fotos* da instalaÃ§Ã£o.\n'
        'Quando terminar, digite /finalizar',
        parse_mode='Markdown'
    )
    return AGUARDANDO_FOTOS

# Receber fotos
async def receber_foto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'fotos' not in context.user_data:
        context.user_data['fotos'] = []
    
    # Pega a foto de maior resoluÃ§Ã£o
    photo = update.message.photo[-1]
    file_id = photo.file_id
    context.user_data['fotos'].append(file_id)
    
    num_fotos = len(context.user_data['fotos'])
    
    if num_fotos < 3:
        await update.message.reply_text(
            f'âœ… Foto {num_fotos}/3 recebida!\n'
            f'Envie mais {3 - num_fotos} foto(s) ou /finalizar se jÃ¡ enviou todas.'
        )
    else:
        await update.message.reply_text(
            f'âœ… {num_fotos} fotos recebidas!\n'
            'Digite /finalizar para salvar a instalaÃ§Ã£o.'
        )
    
    return AGUARDANDO_FOTOS

# Finalizar registro
async def finalizar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'sa' not in context.user_data or 'gpon' not in context.user_data:
        await update.message.reply_text('âŒ Erro: Dados incompletos. Use /start para comeÃ§ar novamente.')
        return ConversationHandler.END
    
    dados = carregar_dados()
    usuarios = carregar_usuarios()
    uid = str(update.message.from_user.id)
    perfil = usuarios.get(uid)
    tecnico_nome = (f"{perfil.get('nome','')} {perfil.get('sobrenome','')}".strip() if perfil else (update.message.from_user.username or update.message.from_user.first_name))
    tecnico_regiao = (perfil.get('regiao') if perfil else None)
    
    nova_instalacao = {
        'sa': context.user_data['sa'],
        'gpon': context.user_data['gpon'],
        'fotos': context.user_data.get('fotos', []),
        'tecnico_id': update.message.from_user.id,
        'tecnico_nome': tecnico_nome,
        'tecnico_regiao': tecnico_regiao,
        'data': datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    }
    
    dados.append(nova_instalacao)
    salvar_dados(dados)
    
    await update.message.reply_text(
        'âœ… *InstalaÃ§Ã£o registrada com sucesso!*\n\n'
        f'ğŸ“‹ SA: `{nova_instalacao["sa"]}`\n'
        f'ğŸ”Œ GPON: `{nova_instalacao["gpon"]}`\n'
        f'ğŸ“¸ Fotos: {len(nova_instalacao["fotos"])}\n'
        f'ğŸ‘¤ TÃ©cnico: {nova_instalacao["tecnico_nome"]}\n'
        f'ğŸ“ RegiÃ£o: {nova_instalacao["tecnico_regiao"] or "nÃ£o informada"}\n'
        f'ğŸ“… Data: {nova_instalacao["data"]}\n\n'
        'Use /start para nova aÃ§Ã£o.',
        parse_mode='Markdown'
    )
    
    context.user_data.clear()
    return ConversationHandler.END

# Consultar por SA
async def consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    gpon_busca = update.message.text.strip()
    dados = carregar_dados()
    
    resultados = [d for d in dados if gpon_busca.lower() in d['gpon'].lower()]
    
    if not resultados:
        await update.message.reply_text(
            f'âŒ Nenhuma instalaÃ§Ã£o encontrada para GPON: `{gpon_busca}`',
            parse_mode='Markdown'
        )
        return
    
    for resultado in resultados:
        msg = (
            f'ğŸ“‹ *SA:* `{resultado["sa"]}`\n'
            f'ğŸ”Œ *GPON:* `{resultado["gpon"]}`\n'
            f'ğŸ‘¤ *TÃ©cnico:* {resultado["tecnico_nome"]}\n'
            f'ğŸ“… *Data:* {resultado["data"]}\n'
            f'ğŸ“¸ *Fotos:* {len(resultado["fotos"])}'
        )
        
        await update.message.reply_text(msg, parse_mode='Markdown')
        
        # Enviar as fotos
        for foto_id in resultado['fotos']:
            try:
                await update.message.reply_photo(photo=foto_id)
            except:
                pass

# Comando /mensal (atalho direto)
async def comando_mensal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_mensal()
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /semanal (atalho direto)
async def comando_semanal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_semanal()
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /hoje (atalho direto)
async def comando_hoje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_hoje()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def receber_data_inicio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        inicio = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('âŒ Data invÃ¡lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_INICIO
    context.user_data['data_inicio'] = inicio
    await update.message.reply_text('Agora envie a *data final* no formato `dd/mm/aaaa`:', parse_mode='Markdown')
    return AGUARDANDO_DATA_FIM

async def receber_data_fim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        fim = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('âŒ Data invÃ¡lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio = context.user_data.get('data_inicio')
    if not inicio:
        await update.message.reply_text('âŒ Erro: envie a data inicial primeiro.', parse_mode='Markdown')
        return ConversationHandler.END
    if fim < inicio:
        await update.message.reply_text('âŒ A data final Ã© anterior Ã  inicial. Envie novamente a data final.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio_dt = inicio.replace(hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=TZ)
    fim_dt = fim.replace(hour=23, minute=59, second=59, microsecond=0).replace(tzinfo=TZ)
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'âŒ Nenhuma instalaÃ§Ã£o encontrada entre {inicio.strftime("%d/%m/%Y")} e {fim.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        context.user_data.pop('data_inicio', None)
        return ConversationHandler.END
    msg = (
        f'ğŸ“† *RelatÃ³rio por PerÃ­odo*\n'
        f'PerÃ­odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
        f'ğŸ‘¤ TÃ©cnico: {username}\n\n'
        f'ğŸ“Š *Total de InstalaÃ§Ãµes:* {len(instalacoes_user)}\n\n'
    )
    ultimos = instalacoes_user[-10:]
    i = 1
    for inst in ultimos:
        msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
        msg += f'   Data: {inst["data"]}\n\n'
        i += 1
    await update.message.reply_text(msg, parse_mode='Markdown')
    context.user_data.pop('data_inicio', None)
    return ConversationHandler.END

# Cancelar operaÃ§Ã£o
async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('âŒ OperaÃ§Ã£o cancelada. Use /start para comeÃ§ar novamente.')
    context.user_data.clear()
    return ConversationHandler.END

# Configurar o bot
def main():
    def _clean_token(s: str):
        s = s.strip()
        for ch in ('`', '"', "'", '\r', '\n'):
            s = s.replace(ch, '')
        return s

    def _get_token():
        t = os.getenv("TELEGRAM_TOKEN")
        if t:
            return _clean_token(t)
        for p in ("/etc/secrets/TELEGRAM_TOKEN", "TELEGRAM_TOKEN"):
            try:
                if os.path.exists(p):
                    with open(p, "r", encoding="utf-8") as f:
                        c = _clean_token(f.read())
                        if c:
                            return c
            except:
                pass
        raise RuntimeError("TELEGRAM_TOKEN nÃ£o definido nas variÃ¡veis de ambiente ou secret file")
    TOKEN = _get_token()
    import re
    if not re.match(r"^\d+:[A-Za-z0-9_-]+$", TOKEN):
        raise RuntimeError("TELEGRAM_TOKEN invÃ¡lido. Verifique se copiou exatamente o token do @BotFather.")
    
    app = Application.builder().token(TOKEN).build()
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start), CallbackQueryHandler(button_callback)],
        states={
            AGUARDANDO_SA: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sa)],
            AGUARDANDO_GPON: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_gpon)],
            AGUARDANDO_FOTOS: [
                MessageHandler(filters.PHOTO, receber_foto),
                CommandHandler('finalizar', finalizar)
            ],
            AGUARDANDO_DATA_INICIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_inicio)],
            AGUARDANDO_DATA_FIM: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_fim)],
            AGUARDANDO_NOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_nome)],
            AGUARDANDO_SOBRENOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sobrenome)],
            AGUARDANDO_REGIAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_regiao)],
        },
        fallbacks=[CommandHandler('cancelar', cancelar)]
    )
    
    app.add_handler(CommandHandler('mensal', comando_mensal))
    app.add_handler(CommandHandler('semanal', comando_semanal))
    app.add_handler(CommandHandler('hoje', comando_hoje))
    app.add_handler(conv_handler)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, consultar))
    
    base_url = os.getenv("WEBHOOK_BASE_URL") or os.getenv("RENDER_EXTERNAL_URL")
    if base_url:
        port = int(os.getenv("PORT", "10000"))
        url_path = TOKEN
        webhook_url = f"{base_url}/{url_path}"
        print('ğŸ¤– Bot iniciado (webhook)! Aguardando mensagens...')
        app.run_webhook(listen="0.0.0.0", port=port, url_path=url_path, webhook_url=webhook_url)
    else:
        print('ğŸ¤– Bot iniciado (polling)! Aguardando mensagens...')
        app.run_polling()

if __name__ == '__main__':
    main()