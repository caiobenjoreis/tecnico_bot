import os
import json
from datetime import datetime, timedelta
from collections import defaultdict
from zoneinfo import ZoneInfo
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ConversationHandler, filters, ContextTypes
from supabase import create_client, Client
from keep_alive import keep_alive

# Estados da conversa
AGUARDANDO_SA, AGUARDANDO_GPON, AGUARDANDO_TIPO, AGUARDANDO_SERIAL, AGUARDANDO_FOTOS, AGUARDANDO_DATA_INICIO, AGUARDANDO_DATA_FIM, AGUARDANDO_NOME, AGUARDANDO_SOBRENOME, AGUARDANDO_REGIAO, AGUARDANDO_CONSULTA, AGUARDANDO_BROADCAST = range(12)

# Arquivo para salvar os dados
DADOS_FILE = 'instalacoes.json'
USUARIOS_FILE = 'usuarios.json'
TZ = ZoneInfo("America/Sao_Paulo")

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")
USE_SUPABASE = bool(SUPABASE_URL and SUPABASE_KEY)
_SUPABASE_CLIENT = None

# Lista de IDs de administradores (adicione seu ID do Telegram aqui)
# Para descobrir seu ID, use o comando /meuid
ADMIN_IDS = [
    1797158471,  # Admin principal
]

PONTOS_SERVICO = {
    'defeito_banda_larga': 1.43,
    'defeito_linha': 1.43,
    'defeito_tv': 1.43,
    'instalacao': 2.28,
    'instalacao_tv': 3.58,
    'mudanca_endereco': 2.37,
    'retirada': 1.06,
    'servicos': 1.50,
    'servico': 1.50
}

TABELA_FAIXAS = [
    {'min': 164.0, 'max': float('inf'), 'faixa': 'A', 'valor': 3.20, 'valor_turbo': 8.00},
    {'min': 159.0, 'max': 163.99, 'faixa': 'B', 'valor': 2.40, 'valor_turbo': 6.00},
    {'min': 148.0, 'max': 158.99, 'faixa': 'C', 'valor': 1.60, 'valor_turbo': 4.00},
    {'min': 137.0, 'max': 147.99, 'faixa': 'D', 'valor': 1.00, 'valor_turbo': 2.50},
    {'min': 126.0, 'max': 136.99, 'faixa': 'E', 'valor': 0.80, 'valor_turbo': 2.25},
    {'min': 120.0, 'max': 125.99, 'faixa': 'F', 'valor': 0.70, 'valor_turbo': 2.00},
    {'min': 115.0, 'max': 119.99, 'faixa': 'G', 'valor': 0.70, 'valor_turbo': 1.75},
    {'min': 109.0, 'max': 114.99, 'faixa': 'H', 'valor': 0.60, 'valor_turbo': 1.50},
    {'min': 0.0,   'max': 108.99, 'faixa': 'I', 'valor': 0.00, 'valor_turbo': 0.00}
]

def _formata_brl(v: float) -> str:
    s = f"{v:,.2f}"
    s = s.replace(',', 'X').replace('.', ',').replace('X', '.')
    return f"R$ {s}"

def calcular_pontos(instalacoes: list) -> float:
    total = 0.0
    for inst in instalacoes:
        tipo = str(inst.get('tipo') or 'instalacao').lower()
        total += PONTOS_SERVICO.get(tipo, 1.0)
    return total

def contar_dias_produtivos(instalacoes: list) -> int:
    dias = set()
    for inst in instalacoes:
        try:
            dt = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M')
            dias.add(dt.date())
        except:
            continue
    return len(dias)

def obter_faixa_valor(pontos: float):
    p = float(pontos)
    for tier in TABELA_FAIXAS:
        if tier['min'] <= p <= tier['max']:
            return tier
    return TABELA_FAIXAS[-1]

def ciclo_atual():
    agora = datetime.now(TZ)
    if agora.day >= 16:
        inicio = datetime(agora.year, agora.month, 16, tzinfo=TZ)
        ano = agora.year + 1 if agora.month == 12 else agora.year
        mes = 1 if agora.month == 12 else agora.month + 1
        fim = datetime(ano, mes, 15, 23, 59, tzinfo=TZ)
    else:
        ano_prev = agora.year - 1 if agora.month == 1 else agora.year
        mes_prev = 12 if agora.month == 1 else agora.month - 1
        inicio = datetime(ano_prev, mes_prev, 16, tzinfo=TZ)
        fim = datetime(agora.year, agora.month, 15, 23, 59, tzinfo=TZ)
    return inicio, fim

def montar_msg_producao(instalacoes_user: list, inicio: datetime, fim: datetime, username: str):
    dias_periodo = (fim - inicio).days + 1
    media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
    pontos = calcular_pontos(instalacoes_user)
    dias_produtivos = contar_dias_produtivos(instalacoes_user)
    turbo_ativo = dias_produtivos >= 24
    tier = obter_faixa_valor(pontos)
    valor_unit = tier['valor_turbo'] if turbo_ativo else tier['valor']
    valor_total = pontos * valor_unit
    
    # Encontrar pr√≥xima faixa
    proxima_faixa = None
    for t in reversed(TABELA_FAIXAS):
        if t['min'] > pontos:
            proxima_faixa = t
            break
            
    # Barra de progresso
    progresso_msg = ""
    if proxima_faixa:
        meta = proxima_faixa['min']
        falta = meta - pontos
        percentual = min(100, (pontos / meta) * 100)
        blocos = int(percentual / 10)
        barra = "‚ñà" * blocos + "‚ñë" * (10 - blocos)
        
        # Estimativa de instala√ß√µes faltantes (m√©dia 1.5 pts por inst)
        inst_faltantes = int(falta / 1.5) + 1
        
        progresso_msg = (
            f'\nüéØ *Pr√≥xima Meta: Faixa {proxima_faixa["faixa"]}*\n'
            f'Progresso: `{barra}` {percentual:.1f}%\n'
            f'Faltam: *{falta:.2f} pontos* (~{inst_faltantes} inst.)\n'
        )
    else:
        progresso_msg = "\nüèÜ *Parab√©ns! Voc√™ atingiu a faixa m√°xima!*\n"

    msg = (
        f'üìÜ *Produ√ß√£o no Per√≠odo*\n'
        f'Per√≠odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
        f'üë§ T√©cnico: {username}\n\n'
        f'üìä *Resumo:*\n'
        f'‚Ä¢ Instala√ß√µes: {len(instalacoes_user)}\n'
        f'‚Ä¢ Pontos: *{pontos:.2f}*\n'
        f'‚Ä¢ Dias Produtivos: {dias_produtivos}/24\n'
        f'‚Ä¢ M√©dia Di√°ria: {media_dia:.1f}\n'
        f'{progresso_msg}\n'
        f'üí∞ *Financeiro:*\n'
        f'‚Ä¢ Faixa Atual: *{tier["faixa"]}*\n'
        f'‚Ä¢ Modo Turbo: {"‚úÖ ATIVO" if turbo_ativo else "‚ùå INATIVO"}\n'
        f'‚Ä¢ Valor Ponto: {_formata_brl(valor_unit)}\n'
        f'‚Ä¢ *Total Estimado: {_formata_brl(valor_total)}*\n'
    )
    return msg

def get_supabase():
    global _SUPABASE_CLIENT
    if not USE_SUPABASE:
        return None
    if _SUPABASE_CLIENT is None:
        _SUPABASE_CLIENT = create_client(SUPABASE_URL, SUPABASE_KEY)
    return _SUPABASE_CLIENT

# Carregar dados existentes
def carregar_dados():
    try:
        sb = get_supabase()
        resp = sb.table("instalacoes").select("*").execute()
        data = resp.data or []
        return data
    except:
        return []

# Salvar dados
def salvar_dados(dados):
    try:
        sb = get_supabase()
        if isinstance(dados, list):
            if dados:
                sb.table("instalacoes").insert(dados).execute()
        else:
            sb.table("instalacoes").insert(dados).execute()
    except:
        pass

def carregar_usuarios():
    try:
        sb = get_supabase()
        resp = sb.table("usuarios").select("*").execute()
        rows = resp.data or []
        usuarios = {}
        for r in rows:
            uid = str(r.get('id'))
            usuarios[uid] = {
                'nome': r.get('nome') or '',
                'sobrenome': r.get('sobrenome') or '',
                'regiao': r.get('regiao'),
                'telegram': r.get('telegram')
            }
        return usuarios
    except:
        return {}

def salvar_usuarios(usuarios):
    try:
        sb = get_supabase()
        payload = []
        for k, v in (usuarios or {}).items():
            payload.append({
                'id': int(k) if str(k).isdigit() else str(k),
                'nome': v.get('nome') or '',
                'sobrenome': v.get('sobrenome') or '',
                'regiao': v.get('regiao'),
                'telegram': v.get('telegram')
            })
        if payload:
            sb.table("usuarios").upsert(payload).execute()
    except:
        pass

def salvar_usuario(uid: str, dados_usuario: dict):
    try:
        sb = get_supabase()
        row = {
            'id': int(uid) if str(uid).isdigit() else str(uid),
            'nome': dados_usuario.get('nome') or '',
            'sobrenome': dados_usuario.get('sobrenome') or '',
            'regiao': dados_usuario.get('regiao'),
            'telegram': dados_usuario.get('telegram')
        }
        sb.table("usuarios").upsert(row).execute()
    except:
        pass

def salvar_instalacao(instalacao: dict):
    try:
        sb = get_supabase()
        sb.table("instalacoes").insert(instalacao).execute()
    except:
        pass

# Comando /ajuda
async def ajuda(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        'üÜò *Central de Ajuda*\n\n'
        'Aqui est√£o os comandos dispon√≠veis:\n\n'
        'üîπ /start - Iniciar o bot e ver o menu principal\n'
        'üîπ /ajuda - Ver esta mensagem de ajuda\n'
        'üîπ /cancelar - Cancelar a opera√ß√£o atual\n'
        'üîπ /meuid - Descobrir seu ID do Telegram\n'
        'üîπ /mensal - Relat√≥rio de produ√ß√£o mensal\n'
        'üîπ /semanal - Relat√≥rio de produ√ß√£o semanal\n'
        'üîπ /hoje - Relat√≥rio de produ√ß√£o de hoje\n'
        'üîπ /consultar - Consultar uma instala√ß√£o por SA ou GPON\n'
        'üîπ /reparo - Iniciar registro de reparo r√°pido\n'
        'üîπ /producao - Consultar produ√ß√£o por per√≠odo\n\n'
        'üí° *Dica:* Se ficar preso em alguma etapa, digite /cancelar para voltar ao in√≠cio.'
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

# Comando /meuid - Descobre o ID do usu√°rio
async def meu_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or "N√£o definido"
    first_name = update.message.from_user.first_name
    
    msg = (
        f'üÜî *Suas Informa√ß√µes*\n\n'
        f'üë§ Nome: {first_name}\n'
        f'üîñ Username: @{username}\n'
        f'üî¢ **ID do Telegram:** `{user_id}`\n\n'
        f'üí° *Para se tornar admin:*\n'
        f'Envie este ID para o administrador do sistema.\n'
        f'Ele deve adicionar `{user_id}` na lista `ADMIN_IDS`.'
    )
    
    await update.message.reply_text(msg, parse_mode='Markdown')

# ==================== PAINEL ADMIN ====================

def is_admin(user_id: int) -> bool:
    """Verifica se o usu√°rio √© administrador"""
    return user_id in ADMIN_IDS

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Painel principal de administra√ß√£o"""
    user_id = update.message.from_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text('‚ùå Acesso negado. Voc√™ n√£o tem permiss√£o de administrador.')
        return
    
    keyboard = [
        [InlineKeyboardButton("üìä Estat√≠sticas Gerais", callback_data='admin_stats')],
        [InlineKeyboardButton("üë• Listar T√©cnicos", callback_data='admin_users')],
        [InlineKeyboardButton("üìã Todas Instala√ß√µes", callback_data='admin_all_installs')],
        [InlineKeyboardButton("ÔøΩ Enviar Mensagem para Todos", callback_data='admin_broadcast')],
        [InlineKeyboardButton("ÔøΩüì§ Exportar Dados", callback_data='admin_export')],
        [InlineKeyboardButton("üîß Gerenciar Admins", callback_data='admin_manage')],
        [InlineKeyboardButton("üîô Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        'üéõÔ∏è *Painel de Administra√ß√£o*\n\n'
        'Escolha uma op√ß√£o:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def admin_stats(query):
    """Mostra estat√≠sticas gerais do sistema"""
    dados = carregar_dados()
    usuarios = carregar_usuarios()
    
    # Estat√≠sticas gerais
    total_instalacoes = len(dados)
    total_tecnicos = len(usuarios)
    
    # Instala√ß√µes por tipo
    por_tipo = defaultdict(int)
    por_categoria = defaultdict(int)
    for inst in dados:
        por_tipo[inst.get('tipo', 'instalacao')] += 1
        por_categoria[inst.get('categoria', 'instalacao')] += 1
    
    # Instala√ß√µes nos √∫ltimos 7 dias
    agora = datetime.now(TZ)
    sete_dias_atras = agora - timedelta(days=7)
    instalacoes_semana = 0
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst >= sete_dias_atras:
                instalacoes_semana += 1
        except:
            continue
    
    # Top 5 t√©cnicos
    por_tecnico = defaultdict(int)
    for inst in dados:
        por_tecnico[inst['tecnico_nome']] += 1
    top_tecnicos = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)[:5]
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = (
        f'üìä *Estat√≠sticas Gerais*\n\n'
        f'üë• *T√©cnicos cadastrados:* {total_tecnicos}\n'
        f'üì¶ *Total de instala√ß√µes:* {total_instalacoes}\n'
        f'üìÖ *√öltimos 7 dias:* {instalacoes_semana}\n\n'
        f'üìã *Por Tipo:*\n'
    )
    
    for tipo, qtd in sorted(por_tipo.items(), key=lambda x: x[1], reverse=True):
        msg += f'  ‚Ä¢ {escape_md(tipo)}: {qtd}\n'
    
    msg += '\nüèÜ *Top 5 T√©cnicos:*\n'
    for idx, (tecnico, qtd) in enumerate(top_tecnicos, 1):
        msg += f'{idx}. {escape_md(tecnico)}: {qtd} instala√ß√µes\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_list_users(query):
    """Lista todos os t√©cnicos cadastrados"""
    usuarios = carregar_usuarios()
    dados = carregar_dados()
    
    # Contar instala√ß√µes por t√©cnico
    instalacoes_por_tecnico = defaultdict(int)
    for inst in dados:
        tecnico_id = str(inst.get('tecnico_id', ''))
        if tecnico_id:
            instalacoes_por_tecnico[tecnico_id] += 1
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = f'üë• *T√©cnicos Cadastrados ({len(usuarios)})*\n\n'
    
    for user_id, dados_user in sorted(usuarios.items(), key=lambda x: instalacoes_por_tecnico.get(x[0], 0), reverse=True):
        nome_completo = f"{dados_user.get('nome', '')} {dados_user.get('sobrenome', '')}".strip()
        regiao = dados_user.get('regiao', 'N/A')
        qtd_instalacoes = instalacoes_por_tecnico.get(user_id, 0)
        is_adm = 'üëë' if int(user_id) in ADMIN_IDS else ''
        
        msg += f'{is_adm} *{escape_md(nome_completo)}*\n'
        msg += f'  ID: `{user_id}`\n'
        msg += f'  Regi√£o: {escape_md(regiao)}\n'
        msg += f'  Instala√ß√µes: {qtd_instalacoes}\n\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_all_installations(query):
    """Lista todas as instala√ß√µes recentes"""
    dados = carregar_dados()
    
    # Pegar as √∫ltimas 20 instala√ß√µes
    ultimas = dados[-20:] if len(dados) > 20 else dados
    ultimas.reverse()  # Mais recentes primeiro
    
    # Escapar underscores para Markdown
    def escape_md(text):
        return str(text).replace('_', '\\_')
    
    msg = f'üìã *√öltimas Instala√ß√µes ({len(ultimas)}/{len(dados)})*\n\n'
    
    for inst in ultimas:
        msg += f'üìÖ {escape_md(inst["data"])}\n'
        msg += f'SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
        msg += f'üë§ {escape_md(inst["tecnico_nome"])}\n'
        msg += f'üß© {escape_md(inst.get("tipo", "instalacao"))}\n\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_export_data(query):
    """Exporta dados em formato texto"""
    dados = carregar_dados()
    usuarios = carregar_usuarios()
    
    # Criar relat√≥rio completo
    agora = datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    
    msg = f'üì§ *Exporta√ß√£o de Dados*\n'
    msg += f'Data: {agora}\n\n'
    msg += f'Total de instala√ß√µes: {len(dados)}\n'
    msg += f'Total de t√©cnicos: {len(usuarios)}\n\n'
    msg += 'üíæ Para exportar dados completos, acesse o Supabase Dashboard:\n'
    msg += f'{SUPABASE_URL if SUPABASE_URL else "Configure SUPABASE_URL"}\n\n'
    msg += 'üìä Voc√™ tamb√©m pode usar os comandos:\n'
    msg += '/mensal - Relat√≥rio mensal\n'
    msg += '/semanal - Relat√≥rio semanal\n'
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_manage_admins(query):
    """Gerenciar administradores"""
    msg = (
        'üîß *Gerenciar Administradores*\n\n'
        f'Admins atuais: {len(ADMIN_IDS)}\n\n'
        'üìù Para adicionar/remover admins:\n'
        '1. Edite o arquivo `tecnico_bot`\n'
        '2. Encontre a lista `ADMIN_IDS`\n'
        '3. Adicione ou remova IDs\n'
        '4. Fa√ßa deploy novamente\n\n'
        'üí° *Como descobrir um ID:*\n'
        'Use o comando /meuid ou\n'
        'Pe√ßa para o usu√°rio enviar /start\n'
        'O ID aparecer√° nos logs do Render'
    )
    
    await query.edit_message_text(msg, parse_mode='Markdown')

async def admin_broadcast_start(query):
    """Inicia o processo de broadcast"""
    msg = (
        'üì¢ *Enviar Mensagem para Todos*\n\n'
        'üìù Digite a mensagem que deseja enviar para todos os t√©cnicos cadastrados.\n\n'
        'üí° *Dicas:*\n'
        '‚Ä¢ Use Markdown para formata√ß√£o\n'
        '‚Ä¢ Seja claro e objetivo\n'
        '‚Ä¢ A mensagem ser√° enviada para todos os usu√°rios\n\n'
        '‚ö†Ô∏è Digite /cancelar para cancelar o envio.'
    )
    await query.edit_message_text(msg, parse_mode='Markdown')
    return AGUARDANDO_BROADCAST

async def admin_send_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia a mensagem broadcast para todos os t√©cnicos"""
    user_id = update.message.from_user.id
    
    if not is_admin(user_id):
        await update.message.reply_text('‚ùå Acesso negado.')
        return ConversationHandler.END
    
    mensagem = update.message.text.strip()
    usuarios = carregar_usuarios()
    
    if not usuarios:
        await update.message.reply_text('‚ùå Nenhum t√©cnico cadastrado para enviar mensagem.')
        return ConversationHandler.END
    
    # Adicionar cabe√ßalho √† mensagem
    mensagem_completa = (
        f'üì¢ *AVISO DA ADMINISTRA√á√ÉO*\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n'
        f'{mensagem}\n\n'
        f'‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ'
    )
    
    # Enviar para todos os usu√°rios
    enviados = 0
    falhas = 0
    
    await update.message.reply_text('üì§ Enviando mensagem para todos os t√©cnicos...')
    
    for uid in usuarios.keys():
        try:
            await context.bot.send_message(
                chat_id=int(uid),
                text=mensagem_completa,
                parse_mode='Markdown'
            )
            enviados += 1
        except Exception as e:
            falhas += 1
            print(f"Erro ao enviar para {uid}: {e}")
    
    # Relat√≥rio de envio
    relatorio = (
        f'‚úÖ *Broadcast Conclu√≠do!*\n\n'
        f'üìä *Estat√≠sticas:*\n'
        f'‚úÖ Enviados: {enviados}\n'
        f'‚ùå Falhas: {falhas}\n'
        f'üë• Total de t√©cnicos: {len(usuarios)}\n\n'
        f'üí° Falhas podem ocorrer se o usu√°rio bloqueou o bot.'
    )
    
    await update.message.reply_text(relatorio, parse_mode='Markdown')
    return ConversationHandler.END

async def admin_callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para callbacks do painel admin"""
    query = update.callback_query
    user_id = query.from_user.id
    
    if not is_admin(user_id):
        await query.answer('‚ùå Acesso negado', show_alert=True)
        return ConversationHandler.END
    
    await query.answer()
    
    if query.data == 'admin_stats':
        await admin_stats(query)
        return None
    elif query.data == 'admin_users':
        await admin_list_users(query)
        return None
    elif query.data == 'admin_all_installs':
        await admin_all_installations(query)
        return None
    elif query.data == 'admin_broadcast':
        return await admin_broadcast_start(query)
    elif query.data == 'admin_export':
        await admin_export_data(query)
        return None
    elif query.data == 'admin_manage':
        await admin_manage_admins(query)
        return None

# ==================== FIM PAINEL ADMIN ====================

# Comando /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    print(f"üîç User ID: {user_id} | Username: {username}")  # Log para descobrir IDs
    
    usuarios = carregar_usuarios()
    if str(user_id) not in usuarios:
        context.user_data['ident'] = {}
        await update.message.reply_text('üë§ Primeiro acesso. Informe seu nome:\n_(Ou /cancelar para sair)_')
        return AGUARDANDO_NOME
    keyboard = [
        [InlineKeyboardButton("üÜï Registrar Instala√ß√£o", callback_data='registrar')],
        [InlineKeyboardButton("üõ†Ô∏è Registrar Reparo", callback_data='registrar_reparo')],
        [InlineKeyboardButton("üîé Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("üìÇ Minhas Instala√ß√µes", callback_data='minhas')],
        [InlineKeyboardButton("üìÖ Consulta Produ√ß√£o", callback_data='consulta_producao')],
        [InlineKeyboardButton("üìä Relat√≥rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        'üõ†Ô∏è *Bot de Registro de Instala√ß√µes*\n\n'
        'Bem-vindo! Escolha uma op√ß√£o:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    return ConversationHandler.END

async def receber_nome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['nome'] = update.message.text.strip()
    await update.message.reply_text('Informe seu sobrenome:\n_(Ou /cancelar para sair)_')
    return AGUARDANDO_SOBRENOME

async def receber_sobrenome(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.setdefault('ident', {})
    context.user_data['ident']['sobrenome'] = update.message.text.strip()
    await update.message.reply_text('Informe sua regi√£o de atua√ß√£o:\n_(Ou /cancelar para sair)_')
    return AGUARDANDO_REGIAO

async def receber_regiao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    regiao = update.message.text.strip()
    user_id = update.message.from_user.id
    usuarios = carregar_usuarios()
    ident = context.user_data.get('ident', {})
    dados_usuario = {
        'nome': ident.get('nome', ''),
        'sobrenome': ident.get('sobrenome', ''),
        'regiao': regiao,
        'telegram': update.message.from_user.username or update.message.from_user.first_name
    }
    usuarios[str(user_id)] = dados_usuario
    salvar_usuario(str(user_id), dados_usuario)
    keyboard = [
        [InlineKeyboardButton("üÜï Registrar Instala√ß√£o", callback_data='registrar')],
        [InlineKeyboardButton("üõ†Ô∏è Registrar Reparo", callback_data='registrar_reparo')],
        [InlineKeyboardButton("üîé Consultar SA/GPON", callback_data='consultar')],
        [InlineKeyboardButton("üìÇ Minhas Instala√ß√µes", callback_data='minhas')],
        [InlineKeyboardButton("üìÖ Consulta Produ√ß√£o", callback_data='consulta_producao')],
        [InlineKeyboardButton("üìä Relat√≥rios", callback_data='relatorios')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        '‚úÖ Perfil salvo!\n\nAgora voc√™ pode usar o menu:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    context.user_data.pop('ident', None)
    return ConversationHandler.END

# Menu de relat√≥rios
async def menu_relatorios(query):
    keyboard = [
        [InlineKeyboardButton("üìÖ Relat√≥rio Mensal", callback_data='rel_mensal')],
        [InlineKeyboardButton("üìä Relat√≥rio Semanal", callback_data='rel_semanal')],
        [InlineKeyboardButton("üìÜ Relat√≥rio por Per√≠odo", callback_data='rel_periodo')],
        [InlineKeyboardButton("üìà Relat√≥rio Hoje", callback_data='rel_hoje')],
        [InlineKeyboardButton("üèÜ Ranking T√©cnicos", callback_data='rel_ranking')],
        [InlineKeyboardButton("üîô Voltar", callback_data='voltar')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        'üìä *Relat√≥rios Dispon√≠veis*\n\n'
        'Escolha o tipo de relat√≥rio:',
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

# Gerar relat√≥rio mensal
def gerar_relatorio_mensal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    mes_atual = agora.month
    ano_atual = agora.year
    
    # Filtrar instala√ß√µes do m√™s atual
    instalacoes_mes = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.month == mes_atual and data_inst.year == ano_atual:
                instalacoes_mes.append(inst)
        except:
            continue
    
    if not instalacoes_mes:
        return "‚ùå Nenhuma instala√ß√£o registrada neste m√™s."
    
    # Contar por t√©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_mes:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    nome_mes = agora.strftime('%B/%Y')
    msg = f'üìÖ *Relat√≥rio Mensal - {nome_mes}*\n\n'
    msg += f'üìä *Total de Instala√ß√µes:* {len(instalacoes_mes)}\n\n'
    msg += 'üë• *Por T√©cnico:*\n'
    
    # Ordenar por quantidade (maior para menor)
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  ‚Ä¢ {tecnico}: *{quantidade}* instala√ß√µes\n'
    
    # M√©dia di√°ria
    dias_mes = agora.day
    media_dia = len(instalacoes_mes) / dias_mes
    msg += f'\nüìà *M√©dia di√°ria:* {media_dia:.1f} instala√ß√µes/dia'
    
    return msg

# Gerar relat√≥rio semanal
def gerar_relatorio_semanal():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    inicio_semana = agora - timedelta(days=agora.weekday())
    inicio_semana = inicio_semana.replace(hour=0, minute=0, second=0, microsecond=0)
    
    # Filtrar instala√ß√µes da semana
    instalacoes_semana = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst >= inicio_semana:
                instalacoes_semana.append(inst)
        except:
            continue
    
    if not instalacoes_semana:
        return "‚ùå Nenhuma instala√ß√£o registrada nesta semana."
    
    # Contar por t√©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_semana:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    msg = f'üìä *Relat√≥rio Semanal*\n'
    msg += f'Per√≠odo: {inicio_semana.strftime("%d/%m")} at√© {agora.strftime("%d/%m/%Y")}\n\n'
    msg += f'üìä *Total de Instala√ß√µes:* {len(instalacoes_semana)}\n\n'
    msg += 'üë• *Por T√©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  ‚Ä¢ {tecnico}: *{quantidade}* instala√ß√µes\n'
    
    # M√©dia di√°ria da semana
    dias_semana = (agora - inicio_semana).days + 1
    media_dia = len(instalacoes_semana) / dias_semana
    msg += f'\nüìà *M√©dia di√°ria:* {media_dia:.1f} instala√ß√µes/dia'
    
    return msg

# Gerar relat√≥rio do dia
def gerar_relatorio_hoje():
    dados = carregar_dados()
    agora = datetime.now(TZ)
    
    # Filtrar instala√ß√µes de hoje
    instalacoes_hoje = []
    for inst in dados:
        try:
            data_inst = datetime.strptime(inst['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if data_inst.date() == agora.date():
                instalacoes_hoje.append(inst)
        except:
            continue
    
    if not instalacoes_hoje:
        return "‚ùå Nenhuma instala√ß√£o registrada hoje."
    
    # Contar por t√©cnico
    por_tecnico = defaultdict(int)
    for inst in instalacoes_hoje:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    msg = f'üìà *Relat√≥rio de Hoje - {agora.strftime("%d/%m/%Y")}*\n\n'
    msg += f'üìä *Total de Instala√ß√µes:* {len(instalacoes_hoje)}\n\n'
    msg += 'üë• *Por T√©cnico:*\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    for tecnico, quantidade in tecnicos_ordenados:
        msg += f'  ‚Ä¢ {tecnico}: *{quantidade}* instala√ß√µes\n'
    
    return msg

# Gerar ranking geral
def gerar_ranking_tecnicos():
    dados = carregar_dados()
    
    if not dados:
        return "‚ùå Nenhuma instala√ß√£o registrada ainda."
    
    # Contar por t√©cnico (todos os tempos)
    por_tecnico = defaultdict(int)
    for inst in dados:
        por_tecnico[inst['tecnico_nome']] += 1
    
    # Montar relat√≥rio
    msg = f'üèÜ *Ranking Geral de T√©cnicos*\n\n'
    msg += f'üìä *Total Geral:* {len(dados)} instala√ß√µes\n\n'
    
    tecnicos_ordenados = sorted(por_tecnico.items(), key=lambda x: x[1], reverse=True)
    
    medals = ['ü•á', 'ü•à', 'ü•â']
    for idx, (tecnico, quantidade) in enumerate(tecnicos_ordenados, 1):
        medal = medals[idx-1] if idx <= 3 else f'{idx}¬∫'
        percentual = (quantidade / len(dados)) * 100
        msg += f'{medal} *{tecnico}*\n'
        msg += f'   {quantidade} instala√ß√µes ({percentual:.1f}%)\n\n'
    
    return msg

# Callback dos bot√µes
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data == 'registrar':
        context.user_data['modo_registro'] = 'instalacao'
        await query.edit_message_text(
            'üÜï *Nova Instala√ß√£o*\n\n'
            'Por favor, envie o *n√∫mero da SA*:\n'
            '_(Ou digite /cancelar para voltar)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'registrar_reparo':
        context.user_data['modo_registro'] = 'reparo'
        await query.edit_message_text(
            'üõ†Ô∏è *Novo Reparo*\n\n'
            'Por favor, envie o *n√∫mero da SA:*:\n'
            '_(Ou digite /cancelar para voltar)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SA
    
    elif query.data == 'consultar':
        await query.edit_message_text(
            'üîé *Consultar Instala√ß√£o*\n\n'
            'Digite o n√∫mero da SA ou do GPON para buscar:',
            parse_mode='Markdown'
        )
        return AGUARDANDO_CONSULTA

    elif query.data == 'consulta_producao':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        inicio_dt, fim_dt = ciclo_atual()
        instalacoes_user = []
        for d in dados:
            try:
                data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
                if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                    instalacoes_user.append(d)
            except:
                continue
        if not instalacoes_user:
            msg = f'‚ùå Nenhuma instala√ß√£o entre {inicio_dt.strftime("%d/%m/%Y")} e {fim_dt.strftime("%d/%m/%Y")}.'
            await query.edit_message_text(msg, parse_mode='Markdown')
            return None
        msg = montar_msg_producao(instalacoes_user, inicio_dt, fim_dt, username)
        
        keyboard = [[InlineKeyboardButton("üìÑ Ver Detalhes", callback_data='detalhes_producao')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(msg, parse_mode='Markdown', reply_markup=reply_markup)
        return None
    
    elif query.data == 'detalhes_producao':
        dados = carregar_dados()
        user_id = query.from_user.id
        inicio_dt, fim_dt = ciclo_atual()
        
        instalacoes_user = []
        for d in dados:
            try:
                data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
                if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                    instalacoes_user.append(d)
            except:
                continue
                
        if not instalacoes_user:
            await query.answer("Nenhuma instala√ß√£o encontrada.", show_alert=True)
            return None
            
        # Gerar arquivo de texto ou mensagem longa
        msg = f"üìÑ *Detalhes do Ciclo ({inicio_dt.strftime('%d/%m')} - {fim_dt.strftime('%d/%m')})*\n\n"
        for inst in sorted(instalacoes_user, key=lambda x: datetime.strptime(x['data'], '%d/%m/%Y %H:%M'), reverse=True):
            tipo = inst.get('tipo', 'Instala√ß√£o')
            pontos = PONTOS_SERVICO.get(tipo.lower(), 0)
            msg += f"üìÖ {inst['data']} | {pontos} pts\n"
            msg += f"üîß {tipo} | SA: {inst['sa']}\n"
            msg += f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
            
        # Se a mensagem for muito longa, cortar
        if len(msg) > 4000:
            msg = msg[:4000] + "\n\n(Lista truncada devido ao tamanho...)"
            
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'minhas':
        dados = carregar_dados()
        user_id = query.from_user.id
        username = query.from_user.username or query.from_user.first_name
        
        instalacoes_user = [d for d in dados if d.get('tecnico_id') == user_id]
        
        if not instalacoes_user:
            await query.edit_message_text('Voc√™ ainda n√£o registrou nenhuma instala√ß√£o.')
            return None
        
        msg = f'üìÇ *Suas Instala√ß√µes ({len(instalacoes_user)})*\n\n'
        for i, inst in enumerate(instalacoes_user[-10:], 1):  # √öltimas 10
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
        
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'relatorios':
        await menu_relatorios(query)
        return None
    
    elif query.data == 'rel_mensal':
        msg = gerar_relatorio_mensal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_semanal':
        msg = gerar_relatorio_semanal()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_hoje':
        msg = gerar_relatorio_hoje()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    elif query.data == 'rel_periodo':
        await query.edit_message_text(
            'üìÜ *Relat√≥rio por Per√≠odo*\n\nEnvie a *data inicial* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para voltar)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_DATA_INICIO
    
    elif query.data == 'rel_ranking':
        msg = gerar_ranking_tecnicos()
        await query.edit_message_text(msg, parse_mode='Markdown')
        return None
    
    # Callbacks do painel admin
    elif query.data.startswith('admin_'):
        return await admin_callback_handler(update, context)
    
    elif query.data == 'voltar':
        keyboard = [
            [InlineKeyboardButton("üÜï Registrar Instala√ß√£o", callback_data='registrar')],
            [InlineKeyboardButton("üõ†Ô∏è Registrar Reparo", callback_data='registrar_reparo')],
            [InlineKeyboardButton("üîé Consultar SA/GPON", callback_data='consultar')],
            [InlineKeyboardButton("üìÇ Minhas Instala√ß√µes", callback_data='minhas')],
            [InlineKeyboardButton("üìÖ Consulta Produ√ß√£o", callback_data='consulta_producao')],
            [InlineKeyboardButton("üìä Relat√≥rios", callback_data='relatorios')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            'üõ†Ô∏è *Bot de Registro de Instala√ß√µes*\n\n'
            'Bem-vindo! Escolha uma op√ß√£o:',
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        return None

# Receber n√∫mero da SA
async def receber_sa(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sa = update.message.text.strip()
    # Valida√ß√£o removida a pedido do usu√°rio
    context.user_data['sa'] = sa
    await update.message.reply_text(
        '‚úÖ SA registrada!\n\n'
        'Agora envie o *GPON*:\n'
        '_(Ou digite /cancelar para sair)_',
        parse_mode='Markdown'
    )
    return AGUARDANDO_GPON

# Receber GPON
async def receber_gpon(update: Update, context: ContextTypes.DEFAULT_TYPE):
    gpon = update.message.text.strip()
    # Valida√ß√£o removida a pedido do usu√°rio
    context.user_data['gpon'] = gpon
    context.user_data['fotos'] = []
    modo = context.user_data.get('modo_registro') or 'instalacao'
    if modo == 'reparo':
        keyboard = [
            [InlineKeyboardButton('Defeito Banda Larga', callback_data='defeito_banda_larga')],
            [InlineKeyboardButton('Defeito Linha', callback_data='defeito_linha')],
            [InlineKeyboardButton('Defeito TV', callback_data='defeito_tv')],
            [InlineKeyboardButton('Mudan√ßa de Endere√ßo', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('Retirada', callback_data='retirada')],
            [InlineKeyboardButton('Servi√ßos', callback_data='servicos')]
        ]
        prompt = '‚úÖ GPON registrado!\n\nSelecione o *tipo de reparo*:'
    else:
        keyboard = [
            [InlineKeyboardButton('Instala√ß√£o', callback_data='instalacao')],
            [InlineKeyboardButton('Instala√ß√£o TV', callback_data='instalacao_tv')],
            [InlineKeyboardButton('Mudan√ßa de Endere√ßo', callback_data='mudanca_endereco')],
            [InlineKeyboardButton('Servi√ßos', callback_data='servicos')]
        ]
        prompt = '‚úÖ GPON registrado!\n\nSelecione o *tipo de servi√ßo*:'
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(prompt, reply_markup=reply_markup, parse_mode='Markdown')
    return AGUARDANDO_TIPO

# Receber fotos
async def receber_foto(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'fotos' not in context.user_data:
        context.user_data['fotos'] = []
    
    # Pega a foto de maior resolu√ß√£o
    photo = update.message.photo[-1]
    file_id = photo.file_id
    context.user_data['fotos'].append(file_id)
    
    num_fotos = len(context.user_data['fotos'])
    
    if num_fotos < 3:
        await update.message.reply_text(
            f'‚úÖ Foto {num_fotos}/3 recebida!\n'
            f'Envie mais {3 - num_fotos} foto(s) ou /finalizar se j√° enviou todas.'
        )
    else:
        await update.message.reply_text(
            f'‚úÖ {num_fotos} fotos recebidas!\n'
            'Digite /finalizar para salvar a instala√ß√£o.'
        )
    
    return AGUARDANDO_FOTOS

async def receber_tipo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    tipo = query.data
    context.user_data['tipo'] = tipo
    print(f"DEBUG receber_tipo: Tipo selecionado = {tipo}")
    
    # Verificar se precisa do Serial do Modem
    tipos_com_serial = ['instalacao', 'instalacao_tv', 'mudanca_endereco', 'defeito_banda_larga', 'defeito_linha', 'defeito_tv']
    
    if tipo in tipos_com_serial:
        print(f"DEBUG receber_tipo: Tipo {tipo} requer serial, indo para AGUARDANDO_SERIAL")
        await query.edit_message_text(
            '‚úÖ Tipo selecionado!\n\n'
            'üìü Agora envie o *N√∫mero de S√©rie do Modem*:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
        return AGUARDANDO_SERIAL
    else:
        print(f"DEBUG receber_tipo: Tipo {tipo} n√£o requer serial, indo para AGUARDANDO_FOTOS")
        await query.edit_message_text(
            '‚úÖ Tipo selecionado!\n\n'
            'üì∏ Agora envie as *3 fotos* da instala√ß√£o.\n'
            'Quando terminar, digite /finalizar',
            parse_mode='Markdown'
        )
        return AGUARDANDO_FOTOS

async def receber_serial(update: Update, context: ContextTypes.DEFAULT_TYPE):
    serial = update.message.text.strip()
    context.user_data['serial_modem'] = serial
    print(f"DEBUG: Serial recebido: {serial}")
    print(f"DEBUG: Context user_data: {context.user_data}")
    
    await update.message.reply_text(
        '‚úÖ Serial registrado!\n\n'
        'üì∏ Agora envie as *3 fotos* da instala√ß√£o.\n'
        'Quando terminar, digite /finalizar',
        parse_mode='Markdown'
    )
    print("DEBUG: Mensagem enviada, retornando AGUARDANDO_FOTOS")
    return AGUARDANDO_FOTOS

# Finalizar registro
async def finalizar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'sa' not in context.user_data or 'gpon' not in context.user_data:
        await update.message.reply_text('‚ùå Erro: Dados incompletos. Use /start para come√ßar novamente.')
        return ConversationHandler.END
    
    usuarios = carregar_usuarios()
    uid = str(update.message.from_user.id)
    perfil = usuarios.get(uid)
    tecnico_nome = (f"{perfil.get('nome','')} {perfil.get('sobrenome','')}".strip() if perfil else (update.message.from_user.username or update.message.from_user.first_name))
    tecnico_regiao = (perfil.get('regiao') if perfil else None)
    
    nova_instalacao = {
        'sa': context.user_data['sa'],
        'gpon': context.user_data['gpon'],
        'tipo': context.user_data.get('tipo') or 'instalacao',
        'categoria': context.user_data.get('modo_registro') or 'instalacao',
        'fotos': context.user_data.get('fotos', []),
        'tecnico_id': update.message.from_user.id,
        'tecnico_nome': tecnico_nome,
        'tecnico_regiao': tecnico_regiao,
        'serial_modem': context.user_data.get('serial_modem'),
        'data': datetime.now(TZ).strftime('%d/%m/%Y %H:%M')
    }
    
    salvar_instalacao(nova_instalacao)
    
    # Escapar caracteres especiais do Markdown
    def escape_markdown(text):
        if text is None:
            return 'n√£o informada'
        # Escapar caracteres especiais do Markdown v2
        special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
        for char in special_chars:
            text = str(text).replace(char, f'\\{char}')
        return text
    
    msg_parts = [
        '‚úÖ *Instala√ß√£o registrada com sucesso\\!*\n\n',
        f'üìã SA: `{nova_instalacao["sa"]}`\n',
        f'üîå GPON: `{nova_instalacao["gpon"]}`\n'
    ]
    
    if nova_instalacao.get("serial_modem"):
        msg_parts.append(f'üìü Serial: `{nova_instalacao["serial_modem"]}`\n')
    
    msg_parts.extend([
        f'üß© Tipo: {escape_markdown(nova_instalacao["tipo"])}\n',
        f'üóÇÔ∏è Categoria: {escape_markdown(nova_instalacao["categoria"])}\n',
        f'üì∏ Fotos: {len(nova_instalacao["fotos"])}\n',
        f'üë§ T√©cnico: {escape_markdown(nova_instalacao["tecnico_nome"])}\n',
        f'üìç Regi√£o: {escape_markdown(nova_instalacao["tecnico_regiao"])}\n',
        f'üìÖ Data: {escape_markdown(nova_instalacao["data"])}\n\n',
        'Use /start para nova a√ß√£o\\.'
    ])
    
    await update.message.reply_text(
        ''.join(msg_parts),
        parse_mode='MarkdownV2'
    )
    
    context.user_data.clear()
    return ConversationHandler.END

# Consultar instala√ß√£o por SA ou GPON
async def consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto_busca = update.message.text.strip()
    dados = carregar_dados()

    termo = texto_busca.lower()
    resultados = []
    for d in dados:
        sa = str(d.get('sa') or '').lower()
        gpon = str(d.get('gpon') or '').lower()
        if termo in sa or termo in gpon:
            resultados.append(d)

    if not resultados:
        await update.message.reply_text(
            f'‚ùå Nenhuma instala√ß√£o encontrada para: `{texto_busca}`',
            parse_mode='Markdown'
        )
        return ConversationHandler.END

    for resultado in resultados:
        # Escapar caracteres especiais para MarkdownV2
        def escape_md(text):
            if text is None:
                return 'N/A'
            special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
            text = str(text)
            for char in special_chars:
                text = text.replace(char, f'\\{char}')
            return text
        
        msg_parts = [
            f'üìã *SA:* `{resultado["sa"]}`\n',
            f'üîå *GPON:* `{resultado["gpon"]}`\n'
        ]
        
        # Adicionar serial se existir
        if resultado.get("serial_modem"):
            msg_parts.append(f'üìü *Serial:* `{resultado["serial_modem"]}`\n')
        
        msg_parts.extend([
            f'üß© *Tipo:* {escape_md(resultado.get("tipo", "instalacao"))}\n',
            f'üë§ *T√©cnico:* {escape_md(resultado["tecnico_nome"])}\n',
            f'üìÖ *Data:* {escape_md(resultado["data"])}\n',
            f'üì∏ *Fotos:* {len(resultado.get("fotos", []))}'
        ])
        
        msg = ''.join(msg_parts)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2')
        
        # Enviar as fotos
        for foto_id in resultado.get('fotos', []):
            try:
                await update.message.reply_photo(photo=foto_id)
            except:
                pass
    return ConversationHandler.END

async def comando_consultar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        'üîé *Consultar Instala√ß√£o*\n\n'
        'Digite o n√∫mero da SA ou do GPON para buscar:',
        parse_mode='Markdown'
    )
    return AGUARDANDO_CONSULTA

async def comando_mensal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_mensal()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_semanal(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_semanal()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_hoje(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = gerar_relatorio_hoje()
    await update.message.reply_text(msg, parse_mode='Markdown')

async def comando_reparo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['modo_registro'] = 'reparo'
    await update.message.reply_text(
        'üõ†Ô∏è *Novo Reparo*\n\nEnvie o *n√∫mero da SA:*:\n'
        '_(Ou digite /cancelar para voltar)_',
        parse_mode='Markdown'
    )
    return AGUARDANDO_SA

async def receber_data_inicio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        inicio = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('‚ùå Data inv√°lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_INICIO
    context.user_data['data_inicio'] = inicio
    modo = context.user_data.get('modo')
    if modo == 'producao':
        await update.message.reply_text(
            'Agora envie a *data de fechamento* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
    else:
        await update.message.reply_text(
            'Agora envie a *data final* no formato `dd/mm/aaaa`:\n'
            '_(Ou digite /cancelar para sair)_',
            parse_mode='Markdown'
        )
    return AGUARDANDO_DATA_FIM

async def iniciar_producao(update: Update, context: ContextTypes.DEFAULT_TYPE):
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    inicio_dt, fim_dt = ciclo_atual()
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'‚ùå Nenhuma instala√ß√£o entre {inicio_dt.strftime("%d/%m/%Y")} e {fim_dt.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        return ConversationHandler.END
    msg = montar_msg_producao(instalacoes_user, inicio_dt, fim_dt, username)
    await update.message.reply_text(msg, parse_mode='Markdown')
    return ConversationHandler.END

async def receber_data_fim(update: Update, context: ContextTypes.DEFAULT_TYPE):
    texto = update.message.text.strip()
    try:
        fim = datetime.strptime(texto, '%d/%m/%Y')
    except:
        await update.message.reply_text('‚ùå Data inv√°lida. Use o formato dd/mm/aaaa.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio = context.user_data.get('data_inicio')
    if not inicio:
        await update.message.reply_text('‚ùå Erro: envie a data inicial primeiro.', parse_mode='Markdown')
        return ConversationHandler.END
    if fim < inicio:
        await update.message.reply_text('‚ùå A data final √© anterior √† inicial. Envie novamente a data final.', parse_mode='Markdown')
        return AGUARDANDO_DATA_FIM
    inicio_dt = inicio.replace(hour=0, minute=0, second=0, microsecond=0).replace(tzinfo=TZ)
    fim_dt = fim.replace(hour=23, minute=59, second=59, microsecond=0).replace(tzinfo=TZ)
    dados = carregar_dados()
    user_id = update.message.from_user.id
    username = update.message.from_user.username or update.message.from_user.first_name
    instalacoes_user = []
    for d in dados:
        try:
            data_inst = datetime.strptime(d['data'], '%d/%m/%Y %H:%M').replace(tzinfo=TZ)
            if d.get('tecnico_id') == user_id and inicio_dt <= data_inst <= fim_dt:
                instalacoes_user.append(d)
        except:
            continue
    if not instalacoes_user:
        msg = f'‚ùå Nenhuma instala√ß√£o encontrada entre {inicio.strftime("%d/%m/%Y")} e {fim.strftime("%d/%m/%Y")}.'
        await update.message.reply_text(msg, parse_mode='Markdown')
        context.user_data.pop('data_inicio', None)
        context.user_data.pop('modo', None)
        return ConversationHandler.END
    modo = context.user_data.get('modo')
    if modo == 'producao':
        dias_periodo = (fim_dt - inicio_dt).days + 1
        media_dia = len(instalacoes_user) / dias_periodo if dias_periodo > 0 else 0
        pontos = calcular_pontos(instalacoes_user)
        dias_produtivos = contar_dias_produtivos(instalacoes_user)
        turbo_ativo = dias_produtivos >= 24
        tier = obter_faixa_valor(pontos)
        valor_unit = tier['valor_turbo'] if turbo_ativo else tier['valor']
        valor_total = pontos * valor_unit
        msg = (
            f'üìÜ *Produ√ß√£o no Per√≠odo*\n'
            f'Per√≠odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'üë§ T√©cnico: {username}\n\n'
            f'üìä *Total de Instala√ß√µes:* {len(instalacoes_user)}\n'
            f'üî¢ *Pontos:* {int(pontos)}\n'
            f'üè∑Ô∏è *Faixa:* {tier["faixa"]}\n'
            f'üìÖ *Dias produtivos:* {dias_produtivos} (>=24 ativa Turbo)\n'
            f'‚ö° *Modo Turbo:* {"Ativo" if turbo_ativo else "Inativo"}\n'
            f'üíµ *Valor por ponto:* {_formata_brl(valor_unit)}\n'
            f'üí∞ *Valor total:* {_formata_brl(valor_total)}\n'
            f'üìà *M√©dia di√°ria:* {media_dia:.1f} instala√ß√µes/dia\n'
        )
        await update.message.reply_text(msg, parse_mode='Markdown')
    else:
        msg = (
            f'üìÜ *Relat√≥rio por Per√≠odo*\n'
            f'Per√≠odo: {inicio.strftime("%d/%m/%Y")} a {fim.strftime("%d/%m/%Y")}\n'
            f'üë§ T√©cnico: {username}\n\n'
            f'üìä *Total de Instala√ß√µes:* {len(instalacoes_user)}\n\n'
        )
        ultimos = instalacoes_user[-10:]
        i = 1
        for inst in ultimos:
            msg += f'{i}. SA: `{inst["sa"]}` | GPON: `{inst["gpon"]}`\n'
            msg += f'   Data: {inst["data"]}\n\n'
            i += 1
        await update.message.reply_text(msg, parse_mode='Markdown')
    context.user_data.pop('data_inicio', None)
    context.user_data.pop('modo', None)
    return ConversationHandler.END

# Cancelar opera√ß√£o
async def cancelar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('‚ùå Opera√ß√£o cancelada. Use /start para come√ßar novamente.')
    context.user_data.clear()
    return ConversationHandler.END

# Configurar o bot
def main():
    def _clean_token(s: str):
        s = s.strip()
        for ch in ('`', '"', "'", '\r', '\n'):
            s = s.replace(ch, '')
        return s

    def _get_token():
        t = os.getenv("TELEGRAM_TOKEN")
        if t:
            return _clean_token(t)
        for p in ("/etc/secrets/TELEGRAM_TOKEN", "TELEGRAM_TOKEN"):
            try:
                if os.path.exists(p):
                    with open(p, "r", encoding="utf-8") as f:
                        c = _clean_token(f.read())
                        if c:
                            return c
            except:
                pass
        raise RuntimeError("TELEGRAM_TOKEN n√£o definido nas vari√°veis de ambiente ou secret file")
    
    async def post_init(application: Application) -> None:
        await application.bot.set_my_commands([
            BotCommand("start", "Menu principal"),
            BotCommand("ajuda", "Como usar o bot"),
            BotCommand("cancelar", "Cancelar opera√ß√£o atual"),
            BotCommand("meuid", "üÜî Descobrir meu ID"),
            BotCommand("admin", "üéõÔ∏è Painel de administra√ß√£o"),
            BotCommand("mensal", "Relat√≥rio mensal"),
            BotCommand("semanal", "Relat√≥rio semanal"),
            BotCommand("hoje", "Relat√≥rio de hoje"),
            BotCommand("consultar", "Consultar instala√ß√£o"),
            BotCommand("reparo", "Registrar reparo"),
            BotCommand("producao", "Produ√ß√£o por per√≠odo")
        ])
    
    TOKEN = _get_token()
    import re
    if not re.match(r"^\d+:[A-Za-z0-9_-]+$", TOKEN):
        raise RuntimeError("TELEGRAM_TOKEN inv√°lido. Verifique se copiou exatamente o token do @BotFather.")
    if not USE_SUPABASE:
        raise RuntimeError("SUPABASE_URL/SUPABASE_KEY n√£o definidos nas vari√°veis de ambiente")
    
    app = Application.builder().token(TOKEN).post_init(post_init).build()
    
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start), CommandHandler('producao', iniciar_producao), CommandHandler('consultar', comando_consultar), CommandHandler('reparo', comando_reparo), CallbackQueryHandler(button_callback)],
        states={
            AGUARDANDO_SA: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sa)],
            AGUARDANDO_GPON: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_gpon)],
            AGUARDANDO_TIPO: [CallbackQueryHandler(receber_tipo)],
            AGUARDANDO_SERIAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_serial)],
            AGUARDANDO_FOTOS: [
                MessageHandler(filters.PHOTO, receber_foto),
                CommandHandler('finalizar', finalizar)
            ],
            AGUARDANDO_DATA_INICIO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_inicio)],
            AGUARDANDO_DATA_FIM: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_data_fim)],
            AGUARDANDO_NOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_nome)],
            AGUARDANDO_SOBRENOME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_sobrenome)],
            AGUARDANDO_REGIAO: [MessageHandler(filters.TEXT & ~filters.COMMAND, receber_regiao)],
            AGUARDANDO_CONSULTA: [MessageHandler(filters.TEXT & ~filters.COMMAND, consultar)],
            AGUARDANDO_BROADCAST: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_send_broadcast)],
        },
        fallbacks=[CommandHandler('cancelar', cancelar)]
    )
    
    app.add_handler(CommandHandler('admin', admin_panel))
    app.add_handler(CommandHandler('meuid', meu_id))
    app.add_handler(CommandHandler('mensal', comando_mensal))
    app.add_handler(CommandHandler('semanal', comando_semanal))
    app.add_handler(CommandHandler('hoje', comando_hoje))
    app.add_handler(CommandHandler('ajuda', ajuda))
    app.add_handler(conv_handler)
    
    # Iniciar servidor web falso para manter o bot vivo no Render
    keep_alive()
    
    print('ü§ñ Bot iniciado (polling)! Aguardando mensagens...')
    app.run_polling()

if __name__ == '__main__':
    main()
